


du -sch SMARTPRD_A_20200119*




###################
qu.sql
####################

set pagesize 50
set lines 1000
set verify off
set heading on
set feedback on
col SESS format a12
col status format a10
col program format a29
col terminal format a12
col "Machine Name" format a15
col "Machine Name" format a12
col "DB User" format a14
col "Logon Time" format a14
col osuser format a16
set pages 9999
col event for a30
select rpad(s.username,14,' ') as "DB User",osuser, s.sql_id,s.sql_child_number ch,
s.sid||','||s.serial# SESS,s.event,
rpad(upper(substr(s.program,instr(s.program,'\',-1)+1)),29,' ') as "Program",
round(LAST_CALL_ET/60) MINS
from gv$session s
where s.status='ACTIVE' and username is not null
-- and sql_id !='3jjkdbtr11qy9'
-- and s.username not like 'SYS%' and s.username not like 'DBSNMP'
order by LAST_CALL_ET
/
#####################33
planc.sql
#########################3

set lines 155
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','4dqs2k5tynk61')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3
/


=========
SAP QUERY
===========

ALTER session set NLS_DATE_FORMAT='DD-MON-YYYY HH24:MI:SS';

set lines 200 pages 300
col DTE_TIME for a25
col TIME_TAKEN_HH_MM for a20

select distinct A.dt_of_gen, A.dt_of_pos, A.sapbatchrunid, 
(CASE WHEN A.currstatuscode = 'S' THEN 'SUCCESS' ELSE 'PENDING' END) AS SAP_POSTING_STATUS, B.dte_time, B.TIME_TAKEN_HH_MM, 
SUBSTR(A.BKTXT,1,6) AS SAP_POSTING_TYPE, count(*) , TO_DATE(SYSDATE, 'DD-MON-YYYY HH24:MI:SS') as data_extracted_date
from nlp_sap_summary A 
LEFT OUTER JOIN 
(
SELECT DT_OF_GEN, dte_time, 
ABS(CAST(DECODE(substr(dt_of_gen,-2),24,0,substr(dt_of_gen,-2)) AS NUMBER) -  CAST(substr(dte_time,-5,2)  AS NUMBER))||':'||
substr(dte_time,-2) TIME_TAKEN_HH_MM
FROM bpclnlp.sap_log 
WHERE (DT_OF_GEN LIKE '15062020%' OR DT_OF_GEN LIKE '16062020%' OR DT_OF_GEN LIKE '17062020%' OR DT_OF_GEN LIKE '18062020%' )
ORDER BY DT_OF_GEN 
) B ON (A.DT_OF_GEN = B.DT_OF_GEN)
where sapbatchrunid in 
      (
      select distinct sapbatchrunid from vtptposbatch 
      WHERE 
      ---TRUNC(BATCHCLOSEDATE) = TRUNC(SYSDATE)----------
      TRUNC(BATCHCLOSEDATE) BETWEEN TO_DATE ('15-JUN-2020 00:00:00', 'DD-MON-YYYY HH24:MI:SS') AND  TO_DATE('18-JUN-2020 19:59:00', 'DD-MON-YYYY HH24:MI:SS') 
      AND SAPBATCHRUNID IS NOT NULL 
      ) 
AND (A.CURRSTATUSCODE IN ('S','P') OR A.CURRSTATUSCODE IS NULL ) 
AND (SUBSTR(A.BKTXT,1,6) LIKE '%SETTLT%')
group by A.dt_of_gen, B.dte_time, A.dt_of_pos, A.sapbatchrunid, 
(CASE WHEN A.currstatuscode = 'S' THEN 'SUCCESS' ELSE 'PENDING' END), A.sap_status, SUBSTR(A.BKTXT,1,6) ,B.TIME_TAKEN_HH_MM, SYSDATE
order by A.dt_of_gen, A.dt_of_pos ;


=====
12c
==== 
col name for a20
col OPEN_TIME for a35
select INST_ID,CON_ID,NAME,OPEN_MODE from gv$containers;

col name for a20
col OPEN_TIME for a35
select CON_ID,NAME,OPEN_MODE,OPEN_TIME from v$pdbs;




To set undo retention (https://community.oracle.com/thread/855866)
==============

select max(maxquerylen) from v$undostat; (This query need to fire from both the instances in RAC and get the highest value)

MAX(MAXQUERYLEN)
----------------
62057

SQL> show parameter undo

NAME TYPE
------------------------------------ VALUE

undo_management string AUTO
undo_retention integer    25000

SQL> select (62057/60)/60 query,(25000/60)/60 retention from dual;

     QUERY  RETENTION
---------- ----------
17.2380556 6.94444444
Yours query exectuing tenure is 17 hours while yours undo retention is approximate 7 hours,change yours retention period to 20% extra with yours query execution tenure and then check yours query again.

atleast set undo retention to 75000,also you had better tune yours query why its too taking so much time?


To get explain plan quickly
================== 
SQL> select sql_id from v$sql where sql_text like '%NO_SMART_SCAN%' and sql_text not like '%like%';

SQL_ID
-------------
81vy8y7fkvzta

SQL> select plan_table_output from table (dbms_xplan.display_cursor('81vy8y7fkvzta'));
===================================================================



===============
Wait events - 1
==============

col EVENT for a30;
col WAIT_CLASS for a30;
select INST_ID,SID,EVENT,WAIT_CLASS,WAIT_TIME,SECONDS_IN_WAIT,STATE from  gv$session_wait where WAIT_CLASS!='Idle';

col MACHINE for a15
col OSUSER for a15
col USERNAME for a15
select INST_ID,SID,SERIAL#,USERNAME,STATUS,OSUSER,MACHINE,SQL_ID,ROW_WAIT_OBJ#,BLOCKING_SESSION,EVENT from gv$session where SID in ();

select INST_ID,SID,SERIAL#,USERNAME,STATUS,OSUSER,MACHINE,PROGRAM,SQL_ID,ROW_WAIT_OBJ#,BLOCKING_SESSION,EVENT from gv$session where SID in (select SID from  gv$session_wait where WAIT_CLASS!='Idle');

===============
Wait events - 2
==============

col EVENT for a30;
col WAIT_CLASS for a30;
select INST_ID,SID,EVENT,WAIT_CLASS,WAIT_TIME,SECONDS_IN_WAIT,STATE from  gv$session_wait where WAIT_CLASS!='Idle';

SELECT wait_class_id, wait_class, total_waits, time_waited FROM gv$session_wait_class WHERE sid = &SID;

select event, total_waits, time_waited from gv$system_event e, gv$event_name n where n.event_id = e.event_id and e.wait_class_id = &WaitClassId;

Then go with

V$EVENT_HISTOGRAM – to determine whether the TIME_WAITED is evenly distributed across the occurrences of the wait or whether some waits for the events were very long whilst others were short indicating more erratic response times.

==================================================
Currently running sql queries under specific user for the past 1 day
===================================================

col USERNAME for a15
col TARGET for a25
col PCT_COMPLETE for a5
col SQL_TEXT for a50

SELECT   username, SID, SERIAL#, NVL (target, target_desc) target,
         CASE
            WHEN sofar > 0 AND totalwork > 0
               THEN ROUND (sofar / totalwork * 100, 2)
                    || ' %'
         END AS pct_complete,
         ROUND ((time_remaining) / 60, 2) rem_work,
         ROUND ((elapsed_seconds) / 60, 2) comp_work,
         ROUND ((time_remaining + elapsed_seconds) / 60, 2) total_work,s.sql_id,
         SUBSTR (s.sql_id, 2, 2) || ' :: ' || sql_text AS sql_text,to_char(start_time,'YYYY-MM-DD HH24:MI:SS') START_TIME
    FROM gv$session_longops l, gv$sqlarea s
   WHERE s.sql_id = l.sql_id AND username='&username' AND START_TIME > (SYSDATE -1/24)
ORDER BY start_time DESC;

=================================
Long operations with completed details
==================================

COLUMN sid FORMAT 999
COLUMN serial# FORMAT 9999999
COLUMN machine FORMAT A30
COLUMN progress_pct FORMAT 99999999.00
COLUMN elapsed FORMAT A10
COLUMN remaining FORMAT A10

SELECT s.sid,s.serial#,s.machine,ROUND(sl.elapsed_seconds/60) || ':' || MOD(sl.elapsed_seconds,60) elapsed,ROUND(sl.time_remaining/60) || ':' || MOD(sl.time_remaining,60) remaining,ROUND(sl.sofar/sl.totalwork*100, 2) progress_pct FROM v$session s,v$session_longops sl WHERE s.sid = sl.sid AND s.serial# = sl.serial#;



Good Performace scripts
=================
http://canali.web.cern.ch/canali/res/All_Files/Oracle_DBA_monitoring_scripts_Luca_Canali_ver_June2015/

Identify the OS pid
==============
select a.username, a.osuser, a.sid, a.serial#, b.spid from gv$session a, gv$process b where a.paddr = b.addr and a.sid=&SID order by a.username;

=======================
Data dictionary help
=======================
select table_name, comments from dictionary where table_name like '% %';

Instance startup time
======================
set lines 200 pages 900
col HOST_NAME for a20;
col STARTUP_TIME for a30;
select INSTANCE_NAME,HOST_NAME,to_char(STARTUP_TIME,'YYYY-MM-DD HH24:MI:SS') STARTUP_TIME,open_mode, LOGINS,LOG_MODE,STATUS,DATABASE_ROLE,controlfile_type from gv$instance,v$database ORDER BY 1;
select INSTANCE_NAME||':'||HOST_NAME||':'||to_char(STARTUP_TIME,'YYYY-MM-DD HH24-MI')||':'||DECODE(STATUS,'OPEN','Up','Down') from v$instance;

To findout index size in a database
=============================
SQL>  SELECT sum(bytes)/1024/1024/1024 FROM user_segments  WHERE segment_TYPE = 'INDEX' ;

SUM(BYTES)/1024/1024/1024
-------------------------
               3.75488281


Indexes based on status
========================

SQL> SELECT COUNT(*) ,STATUS FROM USER_INDEXES
  2  GROUP BY STATUS;

  COUNT(*) STATUS
---------- --------
       270 VALID


Tablespace Details:
=======================
set pagesize 500 linesize 132 feedback on
column tablespace_name heading Tablespace format a40
column object_count heading 'Objects|(#)' format 999999999
column mb heading Mb format 999999999              
column sum(frags) heading 'Frags|(#)' format 999999999
column avail heading 'Max|(Mb)' format 999999999
column free heading 'Free|(%)' format 999999999
column bytesize heading 'Size|(Mb)' format 999999999
column byteused heading 'Used|(Mb)' format 999999999
column bytefree heading 'Free|(Mb)' format 99999999
column init_ext heading 'Initial|(K)' format 99999999
column next_ext heading 'Next|(K)' format 99999999
break on report
compute sum of object_count bytesize byteused bytefree on report
prompt
prompt "********************************************************************************"
prompt "* DB STATUS REPORT FOR THE INSTANCE 
prompt "********************************************************************************"
select tablespace_name, 
sum(byte)/1048576 bytesize, (sum(byte)/1048576)- (sum(fbyte)/1048576) byteused,
sum(fbyte)/1048576 bytefree, sum(frags),
sum(largest)/1048576 avail, (sum(fbyte)/sum(byte))*100 free
from (select tablespace_name, 0 obj_cnt, 0 ini_ext, 0 nex_ext, 0 byte, sum(bytes) fbyte, count(*) frags, max(bytes) largest
from dba_free_space
group by tablespace_name
union
select tablespace_name,
0, 0, 0, sum(bytes), 0, 0, 0
from dba_data_files
group by tablespace_name
union
select tablespace_name, 0,
initial_extent/1024 ini_ext,
next_extent/1024 nex_ext,
0,0,0,0
from dba_tablespaces where extent_management <> 'LOCAL'
union
select tablespace_name,
count(*) obj_cnt,
0, 0, 0, 0, 0, 0
from dba_segments
group by tablespace_name)
group by tablespace_name
order by 7;

======================================
Tablespace Details with AUTO EXTEND 
======================================
set linesize 200
set pagesize 300
break on report
compute sum of CURRENT_GB AUTO_EXT_GB MAX_GB USED_GB FREE_GB on report
select
                a.tablespace_name,
                round(SUM(a.bytes)/(1024*1024*1024)) CURRENT_GB,
                round(SUM(decode(b.maxextend, null, A.BYTES/(1024*1024*1024), 
                b.maxextend*8192/(1024*1024*1024)))) AUTO_EXT_GB,
                round((SUM(a.bytes)/(1024*1024*1024)) - round(c.Free/1024/1024/1024)) USED_GB,
                round((SUM(decode(b.maxextend, null, A.BYTES/(1024*1024*1024), 
                b.maxextend*8192/(1024*1024*1024))) - (SUM(a.bytes)/(1024*1024*1024) - 
                round(c.Free/1024/1024/1024))),2) FREE_GB,
                round(100*(SUM(a.bytes)/(1024*1024*1024) - 
                round(c.Free/1024/1024/1024))/(SUM(decode(b.maxextend, null, A.BYTES/(1024*1024*1024), 
                b.maxextend*8192/(1024*1024*1024))))) USED_PCT
from
                dba_data_files a,
                sys.filext$ b,
                (SELECT
                               d.tablespace_name ,sum(nvl(c.bytes,0)) Free
                FROM
                               dba_tablespaces d,
                               DBA_FREE_SPACE c
                WHERE
                               d.tablespace_name = c.tablespace_name(+)
                               group by d.tablespace_name) c
WHERE
                a.file_id = b.file#(+)
                and a.tablespace_name = c.tablespace_name
GROUP BY a.tablespace_name, c.Free/1024
ORDER BY USED_PCT desc;

============================================
Tablespace Details with AUTO EXTEND & TEMP
============================================

set pages 100
col Name for a20
SELECT 
/* PERMANENT*/
   d.tablespace_name "Name", 
   TO_CHAR(NVL(a.bytes / 1024 / 1024, 0),'99,999,990.900') "Allocated Size (Mo)", 
   TO_CHAR(NVL(a.bytes - NVL(f.bytes, 0), 0)/1024/1024,'99,999,999.999') "Used (Mo)",
  TO_CHAR(NVL(a.maxbytes / 1024 / 1024, 0),'99,999,990.900') "MAX Size (Mo)",
  TO_CHAR(NVL((a.bytes - NVL(f.bytes, 0)) / a.maxbytes * 100, 0), '990.00')  "Used % (including Autoextend)" 
FROM 
  sys.dba_tablespaces d, 
  (select tablespace_name, sum(bytes) bytes,sum(decode(autoextensible,'YES',maxbytes,bytes)) maxbytes  from dba_data_files group by tablespace_name) a, 
  (select tablespace_name, sum(bytes) bytes from dba_free_space group by tablespace_name) f 
WHERE 
 d.tablespace_name = a.tablespace_name(+) AND 
 d.tablespace_name = f.tablespace_name(+) AND NOT 
 (d.extent_management like 'LOCAL' AND d.contents like 'TEMPORARY') 
UNION ALL 
/* TEMPORARY*/
 SELECT   
 A.tablespace_name "Name" , 
      TO_CHAR(NVL(D.mb_total, 0),'99,999,990.900') "Allocated Size (Mo)",
       TO_CHAR(NVL(SUM (A.used_blocks * D.block_size),0)/1024/1024,  '99,999,990.999') "Used (Mo)", 
       TO_CHAR(NVL(M.maxbytes/1024/1024, 0),'99,999,990.900') "MAX Size (Mo)",
        to_char(nvl((SUM (A.used_blocks * D.block_size)/1024/1024 ) / D.mb_total *100,0),'990.00')  "Used % (including Autoextend)"
FROM     v$sort_segment A,
         (
         SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
         FROM     v$tablespace B, v$tempfile C
         WHERE    B.ts#= C.ts#
         GROUP BY B.name, C.block_size
         ) D,
 ( select tablespace_name,sum(decode(autoextensible,'YES',maxbytes,bytes)) maxbytes  from dba_temp_files group by tablespace_name) M
WHERE    
 A.tablespace_name = D.name
 and D.name= M.tablespace_name
GROUP by 
A.tablespace_name, D.mb_total,M.maxbytes
order by 5 desc ;





===============================
PERTICULAR Tablespace Details:
=================================

set pagesize 500 linesize 132 feedback on
column tablespace_name heading Tablespace format a40     
column sum(frags) heading 'Frags|(#)' format 9999
column avail heading 'Max|(Mb)' format 9999999.99
column free heading 'Free|(%)' format 999.9
column bytesize heading 'Size|(Mb)' format 9999999
column byteused heading 'Used|(Mb)' format 9999990
column bytefree heading 'Free|(Mb)' format 999999
break on report
select tablespace_name, sum(byte)/1048576 bytesize, (sum(byte)/1048576)- (sum(fbyte)/1048576) byteused,sum(fbyte)/1048576 bytefree, sum(frags),
sum(largest)/1048576 avail, (sum(fbyte)/sum(byte))*100 free from (select tablespace_name, 0 obj_cnt, 0 ini_ext, 0 nex_ext, 0 byte, sum(bytes) fbyte, count(*) frags, max(bytes) largest from dba_free_space group by tablespace_name
union
select tablespace_name,0, 0, 0, sum(bytes), 0, 0, 0 from dba_data_files group by tablespace_name
union
select tablespace_name, 0, initial_extent/1024 ini_ext, next_extent/1024 nex_ext,0,0,0,0 from dba_tablespaces where extent_management <> 'LOCAL'
union
select tablespace_name,count(*) obj_cnt,0, 0, 0, 0, 0, 0 from dba_segments group by tablespace_name) where tablespace_name='&TSNAME'
group by tablespace_name order by 6;


Tablespace free storage(%)
=============================

select TABLESPACE_NAME,TABLESPACE_SIZE,(100-USED_PERCENT) "Free(%)" from dba_tablespace_usage_metrics where TABLESPACE_NAME='&TABLESPACE';

=====================
Datafiles of a specific tablespace
======================
set lines 200;
set pages 200;
col FILE_NAME for a65;
select FILE_ID,FILE_NAME,sum(BYTES)/1024/1024 "SIZE IN MB",sum(MAXBYTES)/1024/1024 "MAXSIZE MB",AUTOEXTENSIBLE,TABLESPACE_NAME from dba_data_files where TABLESPACE_NAME='&tablespace' group by FILE_ID,FILE_NAME,AUTOEXTENSIBLE,TABLESPACE_NAME order by FILE_NAME;

Table size more than 1 GB of specific tablespace
================================
col SEGMENT_NAME for a40;
set lines 200;
set pages 300;
col owner for a20;
select OWNER,SEGMENT_NAME,SEGMENT_TYPE,round(BYTES/1024/1024/1024) "SIZE_GB" FROM dba_segments WHERE TABLESPACE_NAME='&TABLESPACE' and bytes/1024/1024/1024 > 1 ORDER BY 4;

select OWNER,TABLE_NAME,SEGMENT_NAME from dba_lobs where SEGMENT_NAME='SYS_LOB0000041833C00002$$';

Table size more than 1 GB
=================
set lines 200;
set pages 300;
col SEGMENT_NAME for a40;
col owner for a20;
select OWNER,SEGMENT_NAME,SEGMENT_TYPE,round(BYTES/1024/1024/1024) "size in GB" FROM dba_segments WHERE SEGMENT_TYPE <> 'INDEX' and SEGMENT_NAME NOT LIKE 'MLOG$%' and bytes/1024/1024/1024 > 1 ORDER BY 4 DESC;


Table size more than 1 GB of specific owner
=============================
set lines 200;
set pages 300;
col SEGMENT_NAME for a40;
col owner for a20;
select OWNER,SEGMENT_NAME,SEGMENT_TYPE,ROUND(BYTES/1024/1024/1024) "size in GB" FROM dba_segments WHERE owner='&owner' and bytes/1024/1024/1024 > 1 ORDER BY 4 DESC;


Object Status (VALID / INVALID)
======================

select count(*),owner,object_type,status from dba_objects where OWNER NOT IN ('APPQOSSYS','AUD_OWNER','DBSNMP','ORACLE','ORACLE_OCM','OUTLN','PUBLIC','SYS','SYSTEM') group by owner,object_type,status order by owner;

select count(*),owner,object_type from dba_objects where OWNER NOT IN ('APPQOSSYS','AUD_OWNER','DBSNMP','ORACLE','ORACLE_OCM','OUTLN','PUBLIC','SYS','SYSTEM') group by owner,object_type order by owner;

select count(*),object_type,status from dba_objects where OWNER='&owner' group by owner,object_type,status order by object_type;

USER_OBJECTS
============

select count(*),object_type from user_objects group by object_type order by object_type;

dba_tablespace_usage_metrics
========================

select * from dba_tablespace_usage_metrics order by used_percent desc;

============================
Tablespace growth details
=============================


SELECT TO_CHAR (sp.begin_interval_time,'YYYY-MM-DD') days 
, ts.tsname
, max(round((tsu.tablespace_size* dt.block_size )/(1024*1024),2) ) cur_size_MB
, max(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) usedsize_MB 
FROM DBA_HIST_TBSPC_SPACE_USAGE tsu
, DBA_HIST_TABLESPACE_STAT ts 
, DBA_HIST_SNAPSHOT sp
, DBA_TABLESPACES dt
WHERE tsu.tablespace_id= ts.ts#
AND tsu.snap_id = sp.snap_id
AND ts.tsname = dt.tablespace_name
-- AND ts.tsname IN ('TBS1') 
GROUP BY TO_CHAR (sp.begin_interval_time,'YYYY-MM-DD'), ts.tsname 
ORDER BY ts.tsname, days;


Tablespace Details 2nd QUERY:
=======================
set wrap off
set linesize 300
SELECT D.TABLESPACE_NAME,SPACE "SUM_SPACE(M)",BLOCKS SUM_BLOCKS,SPACE-NVL(FREE_SPACE,0) "USED_SPACE(M)", 
ROUND((1-NVL(FREE_SPACE,0)/SPACE)*100,2) "USED_RATE(%)",FREE_SPACE "FREE_SPACE(M)" 
FROM  
(SELECT TABLESPACE_NAME,ROUND(SUM(BYTES)/(1024*1024),2) SPACE,SUM(BLOCKS) BLOCKS 
FROM DBA_DATA_FILES 
GROUP BY TABLESPACE_NAME) D, 
(SELECT TABLESPACE_NAME,ROUND(SUM(BYTES)/(1024*1024),2) FREE_SPACE 
FROM DBA_FREE_SPACE 
GROUP BY TABLESPACE_NAME) F 
WHERE  D.TABLESPACE_NAME = F.TABLESPACE_NAME(+) 
UNION ALL  --if have tempfile  
SELECT D.TABLESPACE_NAME,SPACE "SUM_SPACE(M)",BLOCKS SUM_BLOCKS,  
USED_SPACE "USED_SPACE(M)",ROUND(NVL(USED_SPACE,0)/SPACE*100,2) "USED_RATE(%)", 
NVL(FREE_SPACE,0) "FREE_SPACE(M)" 
FROM  
(SELECT TABLESPACE_NAME,ROUND(SUM(BYTES)/(1024*1024),2) SPACE,SUM(BLOCKS) BLOCKS 
FROM DBA_TEMP_FILES 
GROUP BY TABLESPACE_NAME) D, 
(SELECT TABLESPACE_NAME,ROUND(SUM(BYTES_USED)/(1024*1024),2) USED_SPACE, 
ROUND(SUM(BYTES_FREE)/(1024*1024),2) FREE_SPACE 
FROM V$TEMP_SPACE_HEADER 
GROUP BY TABLESPACE_NAME) F 
WHERE  D.TABLESPACE_NAME = F.TABLESPACE_NAME(+);


Tablespace Fourth QUERY incliding Datafiles:
---------------------------------------------

set pagesize 1000
set linesize 135

column file_name format a52
column tablespace_name format a25
column status format a10 trunc
column t format 999,999.00 heading "Total MB"
column a format a4 heading "Aext"
column p format 999,999 heading "% Free"

column aext format a4
SELECT df.file_name,
df.tablespace_name,
(df.bytes/1024/1024) t,
round (NVL((100 * (((fs.s)) / df.BYTES)),0)) p,
decode (ae.y,1,'YES','NO') a,
round(df.MAXBYTES/1024/1024) max_size_MB,
df. status
FROM dba_data_files df,
(SELECT file_id,SUM(bytes) s
FROM dba_free_space
GROUP BY file_id) fs,
(SELECT file#, 1 y
FROM sys.filext$
GROUP BY file#) ae
WHERE df.file_id = fs.file_id
AND ae.file#(+) = df.file_id
ORDER BY 4;

Tablespace Fifth QUERY incliding Datafiles:(AWSOME)
---------------------------------------------
SELECT to_char(sysdate,'YYYY/MM/DD') "sysdate",
       t.tn TableSpaceName,
       round(t.sizes / 1024,3) Total_Size,
       round(u.sizes / 1024,3) Used_Size,
       round((t.sizes - u.sizes)/1024, 3) Free_Size,
       round(u.sizes / t.sizes * 100,0) Used_Pct,
       round((t.sizes - u.sizes)/t.sizes*100,0) FreeRatio
  FROM ( SELECT tablespace_name tn,
                sum( decode(autoextensible,'NO',bytes, 'YES', decode( sign(maxbytes-bytes), 1, maxbytes, bytes) ) ) /1024/1024 Sizes
           FROM dba_data_files
          GROUP BY tablespace_name) t,
       ( SELECT tablespace_name tn,
                sum(bytes)/1024/1024 sizes
           FROM dba_segments
          GROUP BY tablespace_name) u
 WHERE t.tn = u.tn
 ORDER BY FreeRatio;



********************************
Script to Resize Oracle Data Files
**********************************

Following is script from notes to generate the queries to resize the data files:

select 'alter database datafile'||' '''||file_name||''''||' resize '||round(highwater+2)||' '||'m'||';' from (
select /*+ rule */
   a.tablespace_name,
    a.file_name,
   a.bytes/1024/1024 file_size_MB,
    (b.maximum+c.blocks-1)*d.db_block_size/1024/1024 highwater
from dba_data_files a        ,
     (select file_id,max(block_id) maximum        
      from dba_extents        
      group by file_id) b,
      dba_extents c,
     (select value db_block_size        
      from v$parameter        
      where name='db_block_size') d
where a.file_id=  b.file_id
and   c.file_id  = b.file_id
and   c.block_id = b.maximum
order by a.tablespace_name,a.file_name);

===================
PRIVILAGES CHECK
==================

http://www.adp-gmbh.ch/ora/misc/recursively_list_privilege.html

=======================
INACTIVE SESSIONS
=====================

Group by Status
-----------------
select count(*),status from v$session where username is not NULL  group by status;

Group by Machine
-----------------
select count(*),machine from v$session where status='INACTIVE' and username is not nULL group by machine;

select COUNT(*),STATUS,EVENT,USERNAME,MACHINE,Program from v$session where status='INACTIVE' and username is not nULL group by STATUS,EVENT,USERNAME,MACHINE,Program;



Username is not null
--------------------
select count(*) from v$session where status='INACTIVE' and username is not nULL;

select count(*), username from v$session where status='INACTIVE' group by username;

select count(*) from v$session where username is not null;

To kill all inactive sessions
-------------------------


ALTER SYSTEM KILL SESSION 'sid,serial#' IMMEDIATE;

ALTER SYSTEM DISCONNECT SESSION 'sid,serial#' IMMEDIATE; ==> It kills os session also "like kill -9 "


select 'alter system kill session ''' || sid || ','||serial# || ''';'  from V$session where status = 'INACTIVE' and username in (,,,,);

select 'alter system kill session ''' || sid || ','||serial# || ''';'  from V$session
where status = 'INACTIVE' and username not like '%SYS%' and last_call_et > 600 and type = 'USER'
order by last_call_et desc;

You will find the inactive session which connected for more than 10 minutes. By using Above Query

==================
To know logged in session
==================

select sys_context('USERENV','SID') SID from dual;

SQL> select count(*),STATUS FROM V$SESSION GROUP BY STATUS;

  COUNT(*) STATUS
---------- --------
       132 ACTIVE
        76 INACTIVE

============================
Active and Inactive by Machine
===========================
col EVENT for a30;
col USERNAME for a22;
col MACHINE for a40;
col PROGRAM for a40;
Col OSUSER for a10;
set lines 300 pages 9000
select inst_id,sid, serial#, STATUS,EVENT,USERNAME,OSUSER,MACHINE from gv$session where username is not nULL and username NOT IN ('SYS','SYSTEM') and status='ACTIVE' group by STATUS,EVENT,USERNAME,OSUSER,MACHINE,serial#,sid,inst_id order by sid;


All SESSIONS
============== 
select inst_id,sid, serial#, STATUS,EVENT,USERNAME,OSUSER,MACHINE from gv$session where username is not nULL and username <> 'SYS' and username!='SYSTEM' group by STATUS,EVENT,USERNAME,OSUSER,MACHINE,serial#,sid,inst_id order by sid;


SESSIONS WITH SPECIFIC USERNAME
==================================== 
select inst_id,sid, serial#, STATUS,EVENT,USERNAME,OSUSER,MACHINE from gv$session where username='&ENTER_USERNAME' group by STATUS,EVENT,USERNAME,OSUSER,MACHINE,serial#,sid,inst_id order by sid;


Sessions with TIMING
======================
select a.sid,a.serial#,b.spid,a.username, to_char(a.logon_time,'DD-MM HH24:MI:SS') LogonDate, a.osuser, a.status, a.module,a.machine,ceil(a.last_call_et/60) mins ,a.EVENT, a.sql_id from gv$session a, gv$process b where a.paddr = b.addr and  a.status = 'ACTIVE' and a.username is not null order by 8 desc;






==========================
Locks & Blocking sessions
===========================
SELECT DECODE (blocking_session, null, null, 'BLOCKED') status,
sid,
lmode,
request,
ctime duration,
USER,
program,
blocking_session,
DECODE (request, 0, NULL, SQL_TEXT) SQL_TEXT
FROM gv$lock l
JOIN gv$session s USING (sid)
LEFT JOIN gv$sqlarea USING (sql_id)
WHERE block = 1 OR request > 0
ORDER BY status






To know the Process ID of a session (SID)
=========================================== 
SELECT S.SID,P.SPID,S.CLIENT_INFO from v$process p, v$session s where p.addr=s.paddr;



SQL> select count(*) FROM V$SESSION WHERE USERNAME IS NOT NULL;

  COUNT(*)
----------
       191

Process and session count
====================
select resource_name, current_utilization, max_utilization from v$resource_limit where resource_name in ('processes','sessions');

Output:
RESOURCE_NAME CURRENT_UTILIZATION MAX_UTILIZATION
—————————— ——————- —————
processes 146 196
sessions 157 210

=====================
Current sessions
==============
col sid_serial format a10
col program format a30
col OBJECT_NAME for a30
col OSUSER for a15
col USERNAME for a15
col OS_SID for a15
SELECT	s.sid||':'||s.serial# sid_serial,
	p.spid OS_SID,
	s.username,
	s.osuser,
	s.program,
	s.logon_time,
	s.status,
	o.object_name
FROM	v$session	s,
	dba_objects	o,
	v$process	p
WHERE	s.row_wait_obj#	=	o.object_id(+)
AND	s.paddr		=	p.addr
AND	s.type		<>	'BACKGROUND';

=======================
Current processes
====================
set lines 200 pages 300	
col username format a15
col sid format a12
col sql_text format a60 word_wrap
col logon_time format a20
col program1 format a30
col program2 format a30
col term_mach format a30
set lines 132
set trimspool on
alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';
SELECT  s.username,
         s.sid||':'||s.serial# sid,
         p.spid,
         s.logon_time,
	DECODE(sa.sql_text,NULL,'NOT RUNNING ACTIVE SQL',sa.sql_text) sql_text,
         s.program PROGRAM1,
         p.program PROGRAM2,
         s.terminal||':'||s.machine term_mach,
         s.osuser
FROM    v$session s,
        v$process p,
	v$sqlarea	sa
WHERE   s.paddr(+)=p.addr
AND s.sql_address = sa.address(+)
AND s.sql_hash_value = sa.hash_value(+)
AND s.type		<>	'BACKGROUND'
ORDER BY 2;

=============================================================
TOP 20 CPU consuming sessions at present --> http://oradba11g.blogspot.com/2014/05/sql-queries-which-is-using-more-cpu.html
==============================================================

set pages 1000
set lines 1000
col OSPID for a06
col SID for 99999
col SERIAL# for 999999
col SQL_ID for a14
col USERNAME for a15
col PROGRAM for a23
col MODULE for a18
col OSUSER for a10
col MACHINE for a25
select * from (
select p.spid "ospid",
(se.SID),ss.serial#,ss.SQL_ID,ss.username,substr(ss.program,1,22) "program",ss.module,ss.osuser,ss.MACHINE,ss.status,
se.VALUE/100 cpu_usage_sec
from
gv$session ss,
gv$sesstat se,
gv$statname sn,
gv$process p
where
se.STATISTIC# = sn.STATISTIC#
and
NAME like '%CPU used by this session%'
and
se.SID = ss.SID
and ss.username !='SYS' and
ss.status='ACTIVE'
and ss.username is not null
and ss.paddr=p.addr and value > 0
order by se.VALUE desc) where rownum<=20;



=======================================================================
LONG OPERATIONS ON THE DATABASE WITH START_TIME and percent completed
=======================================================================

set lines 1000
COLUMN percent FORMAT 999.99
col sid for 9999
col start_time for a20
col message for a45
SELECT sid,SERIAL#,SQL_ID,to_char(start_time,'dd-mm-yy hh24:mi:ss') start_time,
ELAPSED_SECONDS/60 Elapsed_Mins,TIME_REMAINING/60 "TIME_REMAINING_Mins" ,message,( sofar/totalwork)* 100 percent
FROM gv$session_longops
WHERE sofar/totalwork < 1 and totalwork!=0
/




***     BEGIN   *****************************************************************************************************************************
******************************** Excellant query to findout locks and blocking sessions *************************************************



SET TERMOUT OFF;
COLUMN current_instance NEW_VALUE current_instance NOPRINT;
SELECT rpad(instance_name, 17) current_instance FROM v$instance;
SET TERMOUT ON;

PROMPT 
PROMPT +------------------------------------------------------------------------+
PROMPT | Report   : Blocking Locks                                                   |
PROMPT | Instance : &current_instance                                             |
PROMPT +------------------------------------------------------------------------+

SET ECHO        OFF
SET FEEDBACK    6
SET HEADING     ON
SET LINESIZE    180
SET PAGESIZE    50000
SET TERMOUT     ON
SET TIMING      OFF
SET TRIMOUT     ON
SET TRIMSPOOL   ON
SET VERIFY      OFF

CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES

PROMPT 
PROMPT 
PROMPT +------------------------------------------------------------------------+
PROMPT | BLOCKING LOCKS (Summary)                                               |
PROMPT +------------------------------------------------------------------------+
PROMPT 

SET serveroutput ON FORMAT WRAPPED
SET feedback OFF

DECLARE

    CURSOR cur_BlockingLocks IS
        SELECT
            iw.instance_name                                                    AS waiting_instance
          , sw.status                                                           AS waiting_status
          , lw.sid                                                              AS waiting_sid
          , sw.serial#                                                          AS waiting_serial_num
          , sw.username                                                         AS waiting_oracle_username
          , sw.osuser                                                           AS waiting_os_username
          , sw.machine                                                          AS waiting_machine
          , pw.spid                                                             AS waiting_spid
          , SUBSTR(sw.terminal,0, 39)                                           AS waiting_terminal
          , SUBSTR(sw.program,0, 39)                                            AS waiting_program
          , ROUND(lw.ctime/60)                                                  AS waiting_lock_time_min
          , DECODE (   lh.type
                     , 'CF', 'Control File'
                     , 'DX', 'Distributed Transaction'
                     , 'FS', 'File Set'
                     , 'IR', 'Instance Recovery'
                     , 'IS', 'Instance State'
                     , 'IV', 'Libcache Invalidation'
                     , 'LS', 'Log Start or Log Switch'
                     , 'MR', 'Media Recovery'
                     , 'RT', 'Redo Thread'
                     , 'RW', 'Row Wait'
                     , 'SQ', 'Sequence Number'
                     , 'ST', 'Diskspace Transaction'
                     , 'TE', 'Extend Table'
                     , 'TT', 'Temp Table'
                     , 'TX', 'Transaction'
                     , 'TM', 'DML'
                     , 'UL', 'PLSQL User_lock'
                     , 'UN', 'User Name'
                     , 'Nothing-'
                   )                                                            AS waiter_lock_type
          , DECODE (   lw.request
                     , 0, 'None'                        /* Mon Lock equivalent */
                     , 1, 'NoLock'                      /* N */
                     , 2, 'Row-Share (SS)'              /* L */
                     , 3, 'Row-Exclusive (SX)'          /* R */
                     , 4, 'Share-Table'                 /* S */
                     , 5, 'Share-Row-Exclusive (SSX)'   /* C */
                     , 6, 'Exclusive'                   /* X */
                     ,    '[Nothing]'
                   )                                                            AS waiter_mode_request
          , ih.instance_name                                                    AS locking_instance
          , sh.status                                                           AS locking_status
          , lh.sid                                                              AS locking_sid
          , sh.serial#                                                          AS locking_serial_num
          , sh.username                                                         AS locking_oracle_username
          , sh.osuser                                                           AS locking_os_username
          , sh.machine                                                          AS locking_machine
          , ph.spid                                                             AS locking_spid
          , SUBSTR(sh.terminal,0, 39)                                           AS locking_terminal
          , SUBSTR(sh.program,0, 39)                                            AS locking_program
          , ROUND(lh.ctime/60)                                                  AS locking_lock_time_min
          , aw.sql_text                                                         AS waiting_sql_text
        FROM
            gv$lock     lw
          , gv$lock     lh
          , gv$instance iw
          , gv$instance ih
          , gv$session  sw
          , gv$session  sh
          , gv$process  pw
          , gv$process  ph
          , gv$sqlarea  aw
        WHERE
              iw.inst_id  = lw.inst_id
          AND ih.inst_id  = lh.inst_id
          AND sw.inst_id  = lw.inst_id
          AND sh.inst_id  = lh.inst_id
          AND pw.inst_id  = lw.inst_id
          AND ph.inst_id  = lh.inst_id
          AND aw.inst_id  = lw.inst_id
          AND sw.sid      = lw.sid
          AND sh.sid      = lh.sid
          AND lh.id1      = lw.id1
          AND lh.id2      = lw.id2
          AND lh.request  = 0
          AND lw.lmode    = 0
          AND (lh.id1, lh.id2) IN ( SELECT id1,id2
                                    FROM   gv$lock
                                    WHERE  request = 0
                                    INTERSECT
                                    SELECT id1,id2
                                    FROM   gv$lock
                                    WHERE  lmode = 0
                                  )
          AND sw.paddr  = pw.addr (+)
          AND sh.paddr  = ph.addr (+)
          AND sw.sql_address  = aw.address
        ORDER BY
            iw.instance_name
          , lw.sid;

    TYPE t_BlockingLockRecord IS RECORD (
          WaitingInstanceName       VARCHAR2(16)
        , WaitingStatus             VARCHAR2(8)
        , WaitingSid                NUMBER
        , WaitingSerialNum          NUMBER
        , WaitingOracleUsername     VARCHAR2(30)
        , WaitingOSUsername         VARCHAR2(30)
        , WaitingMachine            VARCHAR2(64)
        , WaitingSpid               VARCHAR2(12)
        , WaitingTerminal           VARCHAR2(30)
        , WaitingProgram            VARCHAR2(48)
        , WaitingLockTimeMinute     NUMBER
        , WaiterLockType            VARCHAR2(30)
        , WaiterModeRequest         VARCHAR2(30)
        , LockingInstanceName       VARCHAR2(16)
        , LockingStatus             VARCHAR2(8)
        , LockingSid                NUMBER
        , LockingSerialNum          NUMBER
        , LockingOracleUsername     VARCHAR2(30)
        , LockingOSUsername         VARCHAR2(30)
        , LockingMachine            VARCHAR2(64)
        , LockingSpid               VARCHAR2(12)
        , LockingTerminal           VARCHAR2(30)
        , LockingProgram            VARCHAR2(48)
        , LockingLockTimeMinute     NUMBER
        , SQLText                   VARCHAR2(1000)

    );

    TYPE t_BlockingLockRecordTable IS TABLE OF t_BlockingLockRecord INDEX BY BINARY_INTEGER;

    v_BlockingLockArray             t_BlockingLockRecordTable;
    v_BlockingLockRec               cur_BlockingLocks%ROWTYPE;
    v_NumBlockingLocksIncidents     BINARY_INTEGER := 0;

BEGIN

    DBMS_OUTPUT.ENABLE(1000000);

    OPEN cur_BlockingLocks;

    LOOP
        FETCH cur_BlockingLocks INTO v_BlockingLockRec;
        EXIT WHEN cur_BlockingLocks%NOTFOUND;

        v_NumBlockingLocksIncidents := v_NumBlockingLocksIncidents + 1;

        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingInstanceName      := v_BlockingLockRec.waiting_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingStatus            := v_BlockingLockRec.waiting_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSid               := v_BlockingLockRec.waiting_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSerialNum         := v_BlockingLockRec.waiting_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOracleUsername    := v_BlockingLockRec.waiting_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingOSUsername        := v_BlockingLockRec.waiting_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingMachine           := v_BlockingLockRec.waiting_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingSpid              := v_BlockingLockRec.waiting_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingTerminal          := v_BlockingLockRec.waiting_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingProgram           := v_BlockingLockRec.waiting_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaitingLockTimeMinute    := v_BlockingLockRec.waiting_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterLockType           := v_BlockingLockRec.waiter_lock_type;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).WaiterModeRequest        := v_BlockingLockRec.waiter_mode_request;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingInstanceName      := v_BlockingLockRec.locking_instance;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingStatus            := v_BlockingLockRec.locking_status;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSid               := v_BlockingLockRec.locking_sid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSerialNum         := v_BlockingLockRec.locking_serial_num;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOracleUsername    := v_BlockingLockRec.locking_oracle_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingOSUsername        := v_BlockingLockRec.locking_os_username;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingMachine           := v_BlockingLockRec.locking_machine;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingSpid              := v_BlockingLockRec.locking_spid;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingTerminal          := v_BlockingLockRec.locking_terminal;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingProgram           := v_BlockingLockRec.locking_program;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).LockingLockTimeMinute    := v_BlockingLockRec.locking_lock_time_min;
        v_BlockingLockArray(v_NumBlockingLocksIncidents).SQLText                  := v_BlockingLockRec.waiting_sql_text;
    END LOOP;

    CLOSE cur_BlockingLocks;

    DBMS_OUTPUT.PUT_LINE('Number of blocking lock incidents: ' || v_BlockingLockArray.COUNT);
    DBMS_OUTPUT.PUT(chr(10));

    FOR RowIndex IN 1 .. v_BlockingLockArray.COUNT
    LOOP
        DBMS_OUTPUT.PUT_LINE('Incident ' || RowIndex);
        DBMS_OUTPUT.PUT_LINE('---------------------------------------------------------------------------------------------------------');
        DBMS_OUTPUT.PUT_LINE('                        WAITING                                  BLOCKING');
        DBMS_OUTPUT.PUT_LINE('                        ---------------------------------------- ----------------------------------------');
        DBMS_OUTPUT.PUT_LINE('Instance Name         : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingInstanceName, 41)   || v_BlockingLockArray(RowIndex).LockingInstanceName);
        DBMS_OUTPUT.PUT_LINE('Oracle SID            : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSid, 41)            || v_BlockingLockArray(RowIndex).LockingSid);
        DBMS_OUTPUT.PUT_LINE('Serial#               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSerialNum, 41)      || v_BlockingLockArray(RowIndex).LockingSerialNum);
        DBMS_OUTPUT.PUT_LINE('Oracle User           : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOracleUsername, 41) || v_BlockingLockArray(RowIndex).LockingOracleUsername);
        DBMS_OUTPUT.PUT_LINE('O/S User              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingOSUsername, 41) || v_BlockingLockArray(RowIndex).LockingOSUsername);
        DBMS_OUTPUT.PUT_LINE('Machine               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingMachine, 41) || v_BlockingLockArray(RowIndex).LockingMachine);
        DBMS_OUTPUT.PUT_LINE('O/S PID               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingSpid, 41) || v_BlockingLockArray(RowIndex).LockingSpid);
        DBMS_OUTPUT.PUT_LINE('Terminal              : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingTerminal, 41) || v_BlockingLockArray(RowIndex).LockingTerminal);
        DBMS_OUTPUT.PUT_LINE('Lock Time             : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingLockTimeMinute || ' minutes', 41)  || v_BlockingLockArray(RowIndex).LockingLockTimeMinute ||' minutes');
        DBMS_OUTPUT.PUT_LINE('Status                : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingStatus, 41) || v_BlockingLockArray(RowIndex).LockingStatus);
        DBMS_OUTPUT.PUT_LINE('Program               : ' || RPAD(v_BlockingLockArray(RowIndex).WaitingProgram, 41) || v_BlockingLockArray(RowIndex).LockingProgram);
        DBMS_OUTPUT.PUT_LINE('Waiter Lock Type      : ' || v_BlockingLockArray(RowIndex).WaiterLockType);
        DBMS_OUTPUT.PUT_LINE('Waiter Mode Request   : ' || v_BlockingLockArray(RowIndex).WaiterModeRequest);
        DBMS_OUTPUT.PUT_LINE('Waiting SQL           : ' || v_BlockingLockArray(RowIndex).SQLText);
        DBMS_OUTPUT.PUT(chr(10));
    END LOOP;

END;
/

SET ECHO        OFF
SET FEEDBACK    6
SET HEADING     ON
SET LINESIZE    256
SET PAGESIZE    50000
SET TERMOUT     ON
SET TIMING      OFF
SET TRIMOUT     ON
SET TRIMSPOOL   ON
SET VERIFY      OFF

CLEAR COLUMNS
CLEAR BREAKS
CLEAR COMPUTES

COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN sid                          FORMAT 999999       HEADING 'SID'
COLUMN sid_serial                   FORMAT a15          HEADING 'SID / Serial#'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN object_owner                 FORMAT a15          HEADING 'Object Owner'
COLUMN object_name                  FORMAT a25          HEADING 'Object Name'
COLUMN object_type                  FORMAT a15          HEADING 'Object Type'
COLUMN locked_mode                                      HEADING 'Locked Mode'

CLEAR BREAKS

PROMPT 
PROMPT 
PROMPT +------------------------------------------------------------------------+
PROMPT | LOCKED OBJECTS                                                         |
PROMPT +------------------------------------------------------------------------+

SELECT
    i.instance_name                       instance_name
  , l.session_id || ' / ' || s.serial#    sid_serial
  , s.status                              session_status
  , l.oracle_username                     locking_oracle_user
  , o.owner                               object_owner
  , o.object_name                         object_name
  , o.object_type                         object_type
  , DECODE (   l.locked_mode
             , 0, 'None'                        /* Mon Lock equivalent */
             , 1, 'NoLock'                      /* N */
             , 2, 'Row-Share (SS)'              /* L */
             , 3, 'Row-Exclusive (SX)'          /* R */
             , 4, 'Share-Table'                 /* S */
             , 5, 'Share-Row-Exclusive (SSX)'   /* C */
             , 6, 'Exclusive'                   /* X */
             ,    '[Nothing]'
           )                  locked_mode
FROM
    dba_objects       o
  , gv$session        s
  , gv$locked_object  l
  , gv$instance       i
WHERE
      i.inst_id     = l.inst_id
  AND s.inst_id     = l.inst_id
  AND s.sid         = l.session_id
  AND o.object_id   = l.object_id
ORDER BY
    i.instance_name
  , l.session_id;




***    END    *****************************************************************************************************************************

=============================================================================================================

SET ECHO off 
REM NAME:   TFSCLOCK.SQL 
REM USAGE:"@path/tfsclock" 
REM ------------------------------------------------------------------------ 
REM REQUIREMENTS: 
REM    SELECT on V_$LOCK, V_$SESSION, SYS.USER$, SYS.OBJ$ 
REM ------------------------------------------------------------------------ 
REM PURPOSE: 
REM    The following locking information script provides fully DECODED 
REM    information regarding the locks currently held in the database. 
REM    The report generated is fairly complex and difficult to read, 
REM    but has considerable detail. 
REM 
REM    The TFTS series contains scripts to provide (less detailed) lock  
REM    information in a formats which are somewhat less difficult to read: 
REM    TFSMLOCK.SQL and TFSLLOCK.SQL. 
REM ------------------------------------------------------------------------ 
REM EXAMPLE: 
REM    Too complex to show a representative sample here 
REM  
REM ------------------------------------------------------------------------ 
REM DISCLAIMER: 
REM    This script is provided for educational purposes only. It is NOT  
REM    supported by Oracle World Wide Technical Support. 
REM    The script has been tested and appears to work as intended. 
REM    You should always run new scripts on a test instance initially. 
REM ------------------------------------------------------------------------ 
REM 

set lines 200 
set pagesize 66 
break on Kill on sid on  username on terminal 
column Kill heading 'Kill String' format a13 
column res heading 'Resource Type' format 999 
column id1 format 9999990 
column id2 format 9999990 
column locking heading 'Lock Held/Lock Requested' format a40 
column lmode heading 'Lock Held' format a20 
column request heading 'Lock Requested' format a20 
column serial# format 9999999 
column username  format a10  heading "Username" 
column terminal heading Term format a10 
column tab format a30 heading "Table Name" 
column owner format a15
column LAddr heading "ID1 - ID2" format a18 
column Lockt heading "Lock Type" format a40 
column command format a25 
column sid format 999999 

select 
nvl(S.USERNAME,'Internal') username,s.SERIAL#, 
        L.SID, 
        nvl(S.TERMINAL,'None') terminal, 
        decode(command, 
0,'None',decode(l.id2,0,U1.NAME||'.'||substr(T1.NAME,1,20),'None')) tab, 
decode(command, 
0,'BACKGROUND', 
1,'Create Table', 
2,'INSERT', 
3,'SELECT', 
4,'CREATE CLUSTER', 
5,'ALTER CLUSTER', 
6,'UPDATE', 
7,'DELETE', 
8,'DROP', 
9,'CREATE INDEX', 
10,'DROP INDEX', 
11,'ALTER INDEX', 
12,'DROP TABLE', 
13,'CREATE SEQUENCE', 
14,'ALTER SEQUENCE', 
15,'ALTER TABLE', 
16,'DROP SEQUENCE', 
17,'GRANT', 
18,'REVOKE', 
19,'CREATE SYNONYM', 
20,'DROP SYNONYM', 
21,'CREATE VIEW', 
22,'DROP VIEW', 
23,'VALIDATE INDEX', 
24,'CREATE PROCEDURE', 
25,'ALTER PROCEDURE', 
26,'LOCK TABLE', 
27,'NO OPERATION', 
28,'RENAME', 
29,'COMMENT', 
30,'AUDIT', 
31,'NOAUDIT', 
32,'CREATE EXTERNAL DATABASE', 
33,'DROP EXTERNAL DATABASE', 
34,'CREATE DATABASE', 
35,'ALTER DATABASE', 
36,'CREATE ROLLBACK SEGMENT', 
37,'ALTER ROLLBACK SEGMENT', 
38,'DROP ROLLBACK SEGMENT', 
39,'CREATE TABLESPACE', 
40,'ALTER TABLESPACE', 
41,'DROP TABLESPACE', 
42,'ALTER SESSION', 
43,'ALTER USER', 
44,'COMMIT', 
45,'ROLLBACK', 
46,'SAVEPOINT', 
47,'PL/SQL EXECUTE', 
48,'SET TRANSACTION', 
49,'ALTER SYSTEM SWITCH LOG', 
50,'EXPLAIN', 
51,'CREATE USER', 
52,'CREATE ROLE', 
53,'DROP USER', 
54,'DROP ROLE', 
55,'SET ROLE', 
56,'CREATE SCHEMA', 
57,'CREATE CONTROL FILE', 
58,'ALTER TRACING', 
59,'CREATE TRIGGER', 
60,'ALTER TRIGGER', 
61,'DROP TRIGGER', 
62,'ANALYZE TABLE', 
63,'ANALYZE INDEX', 
64,'ANALYZE CLUSTER', 
65,'CREATE PROFILE', 
66,'DROP PROFILE', 
67,'ALTER PROFILE', 
68,'DROP PROCEDURE', 
69,'DROP PROCEDURE',
70,'ALTER RESOURCE COST', 
71,'CREATE SNAPSHOT LOG', 
72,'ALTER SNAPSHOT LOG', 
73,'DROP SNAPSHOT LOG', 
74,'CREATE SNAPSHOT', 
75,'ALTER SNAPSHOT', 
76,'DROP SNAPSHOT', 
79,'ALTER ROLE',
85,'TRUNCATE TABLE', 
86,'TRUNCATE CLUSTER', 
87,'-', 
88,'ALTER VIEW', 
89,'-', 
90,'-', 
91,'CREATE FUNCTION', 
92,'ALTER FUNCTION', 
93,'DROP FUNCTION', 
94,'CREATE PACKAGE', 
95,'ALTER PACKAGE', 
96,'DROP PACKAGE', 
97,'CREATE PACKAGE BODY', 
98,'ALTER PACKAGE BODY', 
99,'DROP PACKAGE BODY', 
command||' - ???') COMMAND, 
        decode(L.LMODE,1,'No Lock', 
                2,'Row Share', 
                3,'Row Exclusive', 
                4,'Share', 
                5,'Share Row Exclusive', 
                6,'Exclusive','NONE') lmode, 
        decode(L.REQUEST,1,'No Lock', 
                2,'Row Share', 
                3,'Row Exclusive', 
                4,'Share', 
                5,'Share Row Exclusive', 
                6,'Exclusive','NONE') request, 
l.id1||'-'||l.id2 Laddr, 
l.type||' - '|| 
decode(l.type, 
'BL','Buffer hash table instance lock', 
'CF',' Control file schema global enqueue lock', 
'CI','Cross-instance function invocation instance lock',
'CS','Control file schema global enqueue lock', 
'CU','Cursor bind lock',
'DF','Data file instance lock', 
'DL','Direct loader parallel index create',
'DM','Mount/startup db primary/secondary instance lock', 
'DR','Distributed recovery process lock', 
'DX','Distributed transaction entry lock', 
'FI','SGA open-file information lock', 
'FS','File set lock', 
'HW','Space management operations on a specific segment lock',
'IN','Instance number lock',
'IR','Instance recovery serialization global enqueue lock', 
'IS','Instance state lock',
'IV','Library cache invalidation instance lock', 
'JQ','Job queue lock',
'KK','Thread kick lock',
'MB','Master buffer hash table instance lock', 
'MM','Mount definition gloabal enqueue lock', 
'MR','Media recovery lock', 
'PF','Password file lock',
'PI','Parallel operation lock',
'PR','Process startup lock',
'PS','Parallel operation lock',
'RE','USE_ROW_ENQUEUE enforcement lock', 
'RT','Redo thread global enqueue lock', 
'RW','Row wait enqueue lock', 
'SC','System commit number instance lock', 
'SH','System commit number high water mark enqueue lock', 
'SM','SMON lock',
'SN','Sequence number instance lock', 
'SQ','Sequence number enqueue lock', 
'SS','Sort segment lock',
'ST','Space transaction enqueue lock', 
'SV','Sequence number value lock', 
'TA','Generic enqueue lock', 
'TD','DDL enqueue lock', 
'TE','Extend-segment enqueue lock', 
'TM','DML enqueue lock', 
'TO','Temporary Table Object Enqueue', 
'TT','Temporary table enqueue lock', 
'TX','Transaction enqueue lock', 
'UL','User supplied lock', 
'UN','User name lock', 
'US','Undo segment DDL lock',
'WL','Being-written redo log instance lock', 
'WS','Write-atomic-log-switch global enqueue lock', 
'TS',decode(l.id2,0,'Temporary segment enqueue lock (ID2=0)', 
                    'New block allocation enqueue lock (ID2=1)'), 
'LA','Library cache lock instance lock (A=namespace)', 
'LB','Library cache lock instance lock (B=namespace)', 
'LC','Library cache lock instance lock (C=namespace)', 
'LD','Library cache lock instance lock (D=namespace)', 
'LE','Library cache lock instance lock (E=namespace)', 
'LF','Library cache lock instance lock (F=namespace)', 
'LG','Library cache lock instance lock (G=namespace)', 
'LH','Library cache lock instance lock (H=namespace)', 
'LI','Library cache lock instance lock (I=namespace)', 
'LJ','Library cache lock instance lock (J=namespace)', 
'LK','Library cache lock instance lock (K=namespace)', 
'LL','Library cache lock instance lock (L=namespace)', 
'LM','Library cache lock instance lock (M=namespace)', 
'LN','Library cache lock instance lock (N=namespace)', 
'LO','Library cache lock instance lock (O=namespace)', 
'LP','Library cache lock instance lock (P=namespace)', 
'LS','Log start/log switch enqueue lock', 
'PA','Library cache pin instance lock (A=namespace)', 
'PB','Library cache pin instance lock (B=namespace)', 
'PC','Library cache pin instance lock (C=namespace)', 
'PD','Library cache pin instance lock (D=namespace)', 
'PE','Library cache pin instance lock (E=namespace)', 
'PF','Library cache pin instance lock (F=namespace)', 
'PG','Library cache pin instance lock (G=namespace)', 
'PH','Library cache pin instance lock (H=namespace)', 
'PI','Library cache pin instance lock (I=namespace)', 
'PJ','Library cache pin instance lock (J=namespace)', 
'PL','Library cache pin instance lock (K=namespace)', 
'PK','Library cache pin instance lock (L=namespace)', 
'PM','Library cache pin instance lock (M=namespace)', 
'PN','Library cache pin instance lock (N=namespace)', 
'PO','Library cache pin instance lock (O=namespace)', 
'PP','Library cache pin instance lock (P=namespace)', 
'PQ','Library cache pin instance lock (Q=namespace)', 
'PR','Library cache pin instance lock (R=namespace)', 
'PS','Library cache pin instance lock (S=namespace)', 
'PT','Library cache pin instance lock (T=namespace)', 
'PU','Library cache pin instance lock (U=namespace)', 
'PV','Library cache pin instance lock (V=namespace)', 
'PW','Library cache pin instance lock (W=namespace)', 
'PX','Library cache pin instance lock (X=namespace)', 
'PY','Library cache pin instance lock (Y=namespace)', 
'PZ','Library cache pin instance lock (Z=namespace)', 
'QA','Row cache instance lock (A=cache)', 
'QB','Row cache instance lock (B=cache)', 
'QC','Row cache instance lock (C=cache)', 
'QD','Row cache instance lock (D=cache)', 
'QE','Row cache instance lock (E=cache)', 
'QF','Row cache instance lock (F=cache)', 
'QG','Row cache instance lock (G=cache)', 
'QH','Row cache instance lock (H=cache)', 
'QI','Row cache instance lock (I=cache)', 
'QJ','Row cache instance lock (J=cache)', 
'QL','Row cache instance lock (K=cache)', 
'QK','Row cache instance lock (L=cache)', 
'QM','Row cache instance lock (M=cache)', 
'QN','Row cache instance lock (N=cache)', 
'QO','Row cache instance lock (O=cache)', 
'QP','Row cache instance lock (P=cache)', 
'QQ','Row cache instance lock (Q=cache)', 
'QR','Row cache instance lock (R=cache)', 
'QS','Row cache instance lock (S=cache)', 
'QT','Row cache instance lock (T=cache)', 
'QU','Row cache instance lock (U=cache)', 
'QV','Row cache instance lock (V=cache)', 
'QW','Row cache instance lock (W=cache)', 
'QX','Row cache instance lock (X=cache)', 
'QY','Row cache instance lock (Y=cache)', 
'QZ','Row cache instance lock (Z=cache)','????') Lockt 
from    V$LOCK L,  
        V$SESSION S, 
        SYS.USER$ U1, 
        SYS.OBJ$ T1 
where   L.SID = S.SID  
and     T1.OBJ#  = decode(L.ID2,0,L.ID1,1)  
and     U1.USER# = T1.OWNER# 
and     S.TYPE != 'BACKGROUND' 
order by 1,2,5 
/ 

============================================================================







Locks on database:
===============

SELECT DECODE(request,0,'Holder: ','Waiter: ') ||sid sess, id1, id2, lmode, request, type FROM V$LOCK WHERE (id1, id2, type) IN (SELECT id1, id2, type FROM V$LOCK WHERE request > 0)  ORDER BY id1, request;

select * from (SELECT DECODE(request,0,'Holder: ','Waiter: ')|| sid sess, id1, id2, lmode,request, type FROM gV$LOCK WHERE (id1, id2, type) IN (SELECT id1, id2, type FROM V$LOCK WHERE request>0) ORDER BY id1, request) order by 1 desc ;

SESS                        ID1        ID2      LMODE    REQUEST TY
-------------------- ---------- ---------- ---------- ---------- 
Holder: 140               74233          0          3          0 TM
Waiter: 144               74233          0          0          5 TM

SQL> select event, total_waits from gv$system_event  where event like '%TM%';

EVENT                                                            TOTAL_WAITS
---------------------------------------------------------------- -----------
enq: TM - contention                                                     217
enq: TQ - TM contention                                                  13

SQL> select eq_name, eq_type, req_reason  from v$enqueue_statistics  where eq_type LIKE '%TM%';

EQ_NAME                                                          EQ REQ_REASON
---------------------------------------------------------------- -- ----------------------------------------------------------------
DML                                                              TM contention


To know Sid and Serial# 
========================

select sid,serial# from v$session where sid in (from the above query you get sids);

To kill all locks
=================

ALTER SYSTEM KILL SESSION 'Sid,Serial#' immediate; ==> Sid,Serial# you get from above query

LOCKS ON table
=============

column oracle_username format a15
column os_user_name format a15
column object_name format a37
column object_type format a37
col OBJECT_NAME for a30
col OBJECT_TYPE for a15
select a.session_id,a.oracle_username, a.os_user_name, b.owner "OBJECT OWNER", b.object_name,b.object_type,a.locked_mode from (select object_id, SESSION_ID, ORACLE_USERNAME, OS_USER_NAME, LOCKED_MODE from gv$locked_object) a, (select object_id, owner, object_name,object_type from dba_objects) b where a.object_id=b.object_id;

SESSION_ID ORACLE_USERNAME OS_USER_NAME    OBJECT OWNER                   OBJECT_NAME                    OBJECT_TYPE     LOCKED_MODE
---------- --------------- --------------- ------------------------------ ------------------------------ --------------- -----------
      1470 AIDW1           udbisw1         ACCOUNTINFO                    AI_ODS_RAW_MSG_REJECT          TABLE                     3


To kill above lock, first you need to know SID and SERIAL# by using below query

SQL> select SID,SERIAL# from v$session where SID='1470';

       SID    SERIAL#
---------- ----------
      1470      38711


LOCKS ON table (Metalink query)
======================

set linesize 132 pagesize 300
break on Kill on username on terminal 
column Kill heading 'Kill String' format a13 
column res heading 'Resource Type' format 999 
column id1 format 9999990 
column id2 format 9999990 
column lmode heading 'Lock Held' format a20 
column request heading 'Lock Requested' format a20 
column serial# format 99999 
column username  format a10  heading "Username" 
column terminal heading Term format a6 
column tab format a35 heading "Table Name" 
column owner format a9 
column Address format a18 
column ctime heading "Seconds"
select	nvl(S.USERNAME,'Internal') username, 
	nvl(S.TERMINAL,'None') terminal, 
	L.SID||','||S.SERIAL# Kill, 
	U1.NAME||'.'||substr(T1.NAME,1,20) tab, 
	decode(L.LMODE,1,'No Lock', 
		2,'Row Share', 
		3,'Row Exclusive', 
		4,'Share', 
		5,'Share Row Exclusive', 
		6,'Exclusive',null) lmode, 
	decode(L.REQUEST,1,'No Lock', 
		2,'Row Share', 
		3,'Row Exclusive', 
		4,'Share', 
		5,'Share Row Exclusive', 
		6,'Exclusive',null) request,
        l.ctime
from	gV$LOCK L,  
	gV$SESSION S, 
	SYS.USER$ U1, 
	SYS.OBJ$ T1 
where	L.SID = S.SID  
and	T1.OBJ# = decode(L.ID2,0,L.ID1,L.ID2)  
and	U1.USER# = T1.OWNER# 
and	S.TYPE != 'BACKGROUND' 
order by 1,2,5 
/ 


==================================================
Currently running sql queries under specific user for the past 1 day
===================================================

col USERNAME for a15
col TARGET for a25
col PCT_COMPLETE for a5
col SQL_TEXT for a50

SELECT   username, SID, SERIAL#, NVL (target, target_desc) target,
         CASE
            WHEN sofar > 0 AND totalwork > 0
               THEN ROUND (sofar / totalwork * 100, 2)
                    || ' %'
         END AS pct_complete,
         ROUND ((time_remaining) / 60, 2) rem_work,
         ROUND ((elapsed_seconds) / 60, 2) comp_work,
         ROUND ((time_remaining + elapsed_seconds) / 60, 2) total_work,s.sql_id,
         SUBSTR (s.sql_id, 2, 2) || ' :: ' || sql_text AS sql_text,to_char(start_time,'YYYY-MM-DD HH24:MI:SS') START_TIME
    FROM gv$session_longops l, gv$sqlarea s
   WHERE s.sql_id = l.sql_id AND username='&username' AND START_TIME > (SYSDATE -1)
ORDER BY start_time DESC;


============================================================
Currently running sql queries under specific user (Queries completed/running in last 6 hours)
=============================================================

col USERNAME for a15
col TARGET for a25
col PCT_COMPLETE for a5
col sql_id->sql_text for a50
SELECT   username, SID, SERIAL#, NVL (target, target_desc) target,
         CASE
            WHEN sofar > 0 AND totalwork > 0
               THEN ROUND (sofar / totalwork * 100, 2)
                    || ' %'
         END AS pct_complete,
         ROUND ((time_remaining) / 60, 2) rem_work,
         ROUND ((elapsed_seconds) / 60, 2) comp_work,
         ROUND ((time_remaining + elapsed_seconds) / 60, 2) total_work,s.sql_id||
         ' -> ' || sql_text AS "sql_id->sql_text",to_char(start_time,'YYYY-MM-DD HH24:MI:SS') START_TIME
    FROM gv$session_longops l, gv$sqlarea s
   WHERE s.sql_id = l.sql_id AND START_TIME > (SYSDATE -2/24)
ORDER BY start_time DESC;








=================================================
To findour blockers
=========================================

set echo off
@@save_sqlplus_settings.sql
set lines 132
col event format a30
col username format a14
col machine format a20
select s1.sid, s1.username, s1.event, s1.blocking_session,
s1.seconds_in_wait, s1.wait_time,DECODE(s2.machine,null,s1.machine,s2.machine) machine
from v$session s1,
v$session s2
where s1.blocking_session=s2.sid(+)
and s1.state in ('WAITING')
and s1.wait_class != 'Idle' order by 4,1;
/
@@sqlplus_settings
set echo on

=================================================
To findour blockers - 10g
=========================================

set echo off
@save_sqlplus_settings
col event format a50 word_wrap
col username format a15
col blocking_session format 99999999 head 'BLOCKING|SESSION'
select s1.sid, s1.username, s1.event, s1.blocking_session,
s1.seconds_in_wait, s1.wait_time,s2.blocking_session
from v$session s1,
v$session s2
where s1.blocking_session=s2.sid(+)
and s1.state in ('WAITING')
and s1.wait_class != 'Idle' order by 4,1
/
@sqlplus_settings
set echo on


=================================================
To findour blockers 11g
=========================================

set echo off
@save_sqlplus_settings
col event format a50 word_wrap
col username format a15
col blocking_session format 99999999 head 'BLOCKING|SESSION'
select s1.sid, s1.username, s1.event, s1.blocking_session,
s1.seconds_in_wait, s1.wait_time,s2.blocking_session
from v$session s1,
v$session s2
where s1.blocking_session=s2.sid(+)
and s1.state in ('WAITING')
and s1.wait_class != 'Idle' order by 4,1
/
@sqlplus_settings
set echo on




=========================
To findout DDL/DML locks
========================


col LOCKING_ORACLE_USER for a15;
COLUMN instance_name                FORMAT a9           HEADING 'Instance'
COLUMN sid_serial                   FORMAT a15          HEADING 'SID / Serial#'
COLUMN session_status               FORMAT a9           HEADING 'Status'
COLUMN locking_oracle_user          FORMAT a20          HEADING 'Locking Oracle User'
COLUMN lock_type                    FORMAT a9           HEADING 'Lock Type'
COLUMN mode_held                    FORMAT a10          HEADING 'Mode Held'
COLUMN object                       FORMAT a42          HEADING 'Object'
COLUMN program                      FORMAT a20          HEADING 'Program'
COLUMN wait_time_min                FORMAT 999,999      HEADING 'Wait Time (min)'
CLEAR BREAKS
 SELECT
    i.instance_name                                 instance_name
  , l.session_id || ' / ' || s.serial#              sid_serial
  , s.status                                        session_status
  , s.username                                      locking_oracle_user
  , l.lock_type                                     lock_type
  , l.mode_held                                     mode_held
  , o.owner || '.' || o.object_name                 object
  , SUBSTR(s.program, 0, 20)                        program
  , ROUND(w.seconds_in_wait/60, 2)                  wait_time_min
FROM
    gv$instance      i
  , gv$session       s
  , dba_locks       l
  , dba_objects     o
  , gv$session_wait  w
WHERE 
      s.sid = l.session_id
  AND l.lock_type IN ('DML','DDL')
  AND l.lock_id1 = o.object_id
  AND l.session_id = w.sid
ORDER BY
    i.instance_name
  , l.session_id;


OUTPUT
======

Instance  SID / Serial#   Status    Locking Oracle User  Lock Type Mode Held  Object                                     Program              Wait Time (min)
--------- --------------- --------- -------------------- --------- ---------- ------------------------------------------ -------------------- ---------------
LNPRIST1  240 / 53005     INACTIVE  PRISMA_UI_USER_MO    DML       Row-X (SX) PRISMA_UI_OWNER_MO.SCHED_LEASE                                                0
LNPRIST1  1551 / 24793    ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_LOGINS                       oracle@prisdbsit1 (J           2,646
LNPRIST1  1551 / 24793    ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_STATISTICS                   oracle@prisdbsit1 (J           2,646
LNPRIST1  2205 / 4539     ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_PROCS                        oracle@prisdbsit1 (J               1
LNPRIST1  2205 / 4539     ACTIVE    AUDTASK              DML       Row-X (SX) SYS.AUD$                                   oracle@prisdbsit1 (J               1
LNPRIST1  2205 / 4539     ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_LOGINS                       oracle@prisdbsit1 (J               1
LNPRIST1  2205 / 4539     ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_STATISTICS                   oracle@prisdbsit1 (J               1
LNPRIST1  2205 / 4539     ACTIVE    AUDTASK              DML       Row-X (SX) AUD_OWNER.AUD_COPY                         oracle@prisdbsit1 (J               1

8 rows selected.

To find out any blocking or waiting sessions
==================================

select /*+ ordered */ w1.sid  waiting_session,h1.sid  holding_session, w.kgllktype lock_or_pin,w.kgllkhdl address,decode(h.kgllkmod,  0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive','Unknown') mode_held,decode(w.kgllkreq,  0, 'None', 1, 'Null', 2, 'Share', 3, 'Exclusive', 'Unknown') mode_requested   from dba_kgllock w, dba_kgllock h, gv$session w1, gv$session h1  where   (((h.kgllkmod != 0) and (h.kgllkmod != 1) and ((h.kgllkreq = 0) or (h.kgllkreq = 1)))  and   (((w.kgllkmod = 0) or (w.kgllkmod= 1))  and ((w.kgllkreq != 0) and (w.kgllkreq != 1))))   and  w.kgllktype =  h.kgllktype   and  w.kgllkhdl =  h.kgllkhdl   and  w.kgllkuse  =   w1.saddr   and  h.kgllkuse     =   h1.saddr;


select   blocking_session,   sid,   serial#,   wait_class,   seconds_in_wait from  v$session where   blocking_session is not NULL order by    blocking_session;


====================
Which is blocking what
====================

select s1.username || '@' || s1.machine|| ' ( SID=' || s1.sid || ' ) is blocking '|| s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2 where s1.sid=l1.sid and s2.sid=l2.sid and l1.BLOCK=1 and l2.request > 0 and l1.id1 =l2.id1 and l2.id2 = l2.id2;

Output:
BLOCKING_STATUS
——————————————————————————–
SYS@localhost.localdomain ( SID=19 ) is blocking SYS@localhost.localdomain ( SID=21 )



SELECT TO_CHAR(sysdate, 'DD-MON-YYYY HH24:MI:SS')
|| ' User '
||s1.username
|| '@'
|| s1.machine
|| ' ( SID= '
|| s1.sid
|| ' ) with the statement: '
|| sqlt2.sql_text
||' is blocking the SQL statement on '
|| s2.username
|| '@'
|| s2.machine
|| ' ( SID='
|| s2.sid
|| ' ) blocked SQL -> '
||sqlt1.sql_text AS blocking_status FROM gv$lock l1, gv$session s1 ,gv$lock l2 ,gv$session s2 ,gv$sql sqlt1 ,gv$sql sqlt2 WHERE s1.sid =l1.sid
AND s2.sid =l2.sid AND sqlt1.sql_id= s2.sql_id AND sqlt2.sql_id= s1.prev_sql_id AND l1.BLOCK =1 AND l2.request > 0 AND l1.id1 = l2.id1 AND l2.id2 = l2.id2
/

You will get the blocking session details as below:

BLOCKING_STATUS
--------------------------------------------------------------------------------
02-FEB-2010 01:40:12 User Tom ( SID= 989 ) with the statemen
t: select * from t where a='sdfannsdfb' for update is blocking the SQL statement on Peter@ ( SID=100 ) blocked SQL -> update t set a='x' where a='sdfannsdfb'




=======================================
Find the object being locked from the above output
========================================
SQL> SELECT vl.session_id, do.object_name FROM V$LOCKED_OBJECT vl, dba_objects do WHERE vl.session_id IN (19, 21) and vl.object_id = do.object_id;

output:
SESSION_ID OBJECT_NAME
———— ——————
19 TEST
21 TEST



==========================================
Check and remove session locking other from Database - Find the USER locking others
==========================================

Select a.serial#, a.sid, a.username, b.id1, c.sql_text
from v$session a, v$lock b, v$sqltext c
where b.id1 in
(select distinct e.id1
from v$session d, v$lock e
where d.lockwait = e.kaddr)
and a.sid = b.sid
and c.hash_value = a.sql_hash_value
and b.request = 0;

Output:
----------
USER SERIAL# SID USERNAME ID1 SQL_TEXT
13 23 ALIMA 393242 update authuser.emp set salary=1000

To Kill session
SQL>alter system kill session '23,13';
Session Killed.

          
BACK GROUND RUNNING QUERIES
==============================
set linesize 200
col username form a20 ;
col sql_text format a60 word_wrapped
col event format a20 word_wrapped
select  /*+ RULE */  distinct sid,serial#,username,event,sql_id,sql_text from gv$sql,(select event, sql_hash_value, sid, serial#,username from gv$session where status = 'ACTIVE' and type !='BACKGROUND') where hash_value = sql_hash_value order by username,sid;

===============================================================================
EXCELLANT QUERY to check db file sequential read. After BACK GROUND RUNNING QUERIES, fire this query
=================================================================================

SELECT a.event, SUM (a.time_waited) total, COUNT (*),
ROUND (AVG (a.time_waited)) AVG, o.object_name, object_type, i.table_name
FROM v$active_session_history a, dba_objects o, dba_indexes i
WHERE wait_class = 'User I/O'
AND session_id ='&ENTERSID'
     and i.owner(+) = o.owner
     and i.index_name(+) = o.object_name
AND a.current_obj# = o.object_id
GROUP BY event, current_obj#, o.object_name, o.object_type, i.table_name
ORDER BY 3 DESC;

Long Running Queries:
=================
(1) select  /*+ RULE */  distinct sid,serial#,username,event,sql_id,sql_text from gv$sql, (select event, sql_hash_value, sid, serial#,username from gv$session where status = 'ACTIVE' and type !='BACKGROUND') where hash_value = sql_hash_value order by username,sid;


(2) select /*+ RULE */  distinct s.sid,s.serial#,s.username,s.machine,s.status,v.sql_id,v.sql_text from v$sql v,v$session s where  v.hash_value=s.sql_hash_value order by s.username,s.sid;

3) Long Running Queries (Very GOOD)
====================================
set pagesize 50
set lines 1000
set verify off
set heading on
set feedback on
col SESS format a12
col status format a10
col program format a29
col terminal format a12
col "Machine Name" format a15
col "Machine Name" format a12
col "DB User" format a14
col "Logon Time" format a14
col osuser format a16
set pages 9999
col event for a30
select rpad(s.username,14,' ') as "DB User",osuser, s.sql_id,s.sql_child_number ch,
s.sid||','||s.serial# SESS,s.event,
rpad(upper(substr(s.program,instr(s.program,'\',-1)+1)),29,' ') as "Program",
round(LAST_CALL_ET/60) MINS
from gv$session s
where s.status='ACTIVE' and username is not null
-- and sql_id !='3jjkdbtr11qy9'
and s.username not like 'SYS%' and s.username not like 'DBSNMP'
order by LAST_CALL_ET
/


QUERY TO GET SQL EXECUTION PLAN CHANGE DATE
============================================= 
set lines 155
col execs for 999,999,999
col avg_etime for 999,999.999
col avg_lio for 999,999,999.9
col begin_interval_time for a30
col node for 99999
break on plan_hash_value on startup_time skip 1
select ss.snap_id, ss.instance_number node, begin_interval_time, sql_id, plan_hash_value,
nvl(executions_delta,0) execs,
(elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000 avg_etime,
(buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)) avg_lio
from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
where sql_id = nvl('&sql_id','dzy8106qdndfp')
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1, 2, 3
/








Long Running Queries - 2:(From http://ajwatblog.blogspot.in/search/label/Long%20Running%20sql)
============================================================================

set long 5000
set pages 1000
select  case when max_sql_time is null then 0
    when max_sql_time < 1800 then 0
    when max_sql_time between 1800 and 3600 then 1
    else 2 end
    as return_code, 'OpName is : ' || opname||
    '. The max long running SQL in v$session_longops ran for '|| max_sql_time ||
    ' seconds. Message is ' || message ||
    '. Username is ' || l.username ||
    '. OSuser is ' || sess.osuser||   
    '. Program is '|| sess.program ||
    '. Machine is ' || sess.machine ||
    '. SQL Text is ' || s.sql_fulltext
    as return_statement
    from (select max(elapsed_seconds)
          as max_sql_time,
          username,
          opname,
          message,
          sql_address
          from v$session_longops
          where
           last_update_time > sysdate - interval '15' minute
          and message not like 'RMAN: aggregate input: backup%'
          and message not like 'RMAN: aggregate output: backup%'
          and message not like 'RMAN: incremental datafile backup%'
         group by username, opname, message,sql_address) l,v$sql s,v$session sess
        where l.sql_address=s.address
         AND  sess.sql_address=s.address
       UNION ALL
SELECT 0 as return_code ,to_clob('There are no rows returned') as return_statement   from dual;


Find all record locks ON RECORDS within database
=====================================
SELECT s.sid, s.serial#, s.username, s.status, do.owner, do.object_name, do.object_id, do.object_type, dbms_rowid.rowid_create(1, s.row_wait_obj#, s.row_wait_file#, s.row_wait_block#, s.row_wait_row#) as locked_rowid
FROM v$session s, dba_objects do
WHERE s.row_wait_obj# = do.object_id and object_type = 'TABLE'
order by s.sid, s.serial#;

TEMP Tablespace Usages:
===================
SELECT TABLESPACE_NAME,SUM(BYTES_USED/1024/1024),SUM(BYTES_FREE/1024/1024) FROM v$TEMP_SPACE_HEADER GROUP BY TABLESPACE_NAME;



OS Related:

Memory and CPU related Details:
=========================
prstat –a 
prstat –mL
vmstat 2 2
netset tnlp

Server utilisation
============
sar 2 5
top

sar report historical data
=================
[root@corfcracc201p sa]# pwd
/var/log/sa
[root@corfcracc201p sa]# sar -f sa20 -s 06:30:00 -e 12:00:00 | more

06:30:01 AM       CPU     %user     %nice   %system   %iowait    %steal     %idle
06:40:01 AM       all      4.41      0.00      0.69      0.00      0.00     94.90
06:50:01 AM       all      4.31      0.00      0.66      0.00      0.00     95.03
07:00:01 AM       all      3.84      0.00      0.51      0.00      0.00     95.65

Check process who is taking much swap space:
==================================
(1)	ps -eo pid,vsz,rss,args | sort -rn -k 2,2 | head -20
(2)	swap -l | tail -1 | awk '{ printf("%.2f\n", 100 * ($5/$4))}'
(3)	prstat -s size
(4)	ps -eo vsz,rss,pid,args | sort -n


SWAP Usages:
===========
Swap –l
Swap –s 
df -h /tmp
df -h /swap
top -d1 | grep "total swap"

uname -a
Linux oleracss01p.in.sensis.com.au 2.6.18-194.32.1.el5 #1 SMP Mon Dec 20 10:52:42 EST 2010 x86_64 x86_64 x86_64 GNU/Linux

uname -p
x86_64

uname -v
#1 SMP Mon Dec 20 10:52:42 EST 2010

uname -m
x86_64

uname -s
Linux

cat /proc/version

Linux version 2.6.18-194.32.1.el5 (mockbuild@x86-006.build.bos.redhat.com) (gcc version 4.1.2 20080704 (Red Hat 4.1.2-48)) #1 SMP Mon Dec 20 10:52:42 EST 2010


To get memory details or oracle
================================

prstat -a

=============
to check LDAP users
==============
$getent passwd <username>

==============================
SAR report for perticular day
==============================
ls -l /var/log/sa

$ sar -P ALL -f /var/log/sa/sa08 ==> Sar report for perticular day

processes consuming memory - Linux
---------------------------------------------- 
[root@corfcracrc201p home]# lsof /home |grep -i delete

sh      29960 orastage    1w   REG    8,7 1744379904  65603 /home/orastage/tdrs2.sdw_sdfm.sh.log (deleted)
sh      29960 orastage    2w   REG    8,7 1744379904  65603 /home/orastage/tdrs2.sdw_sdfm.sh.log (deleted)
expdp   29961 orastage    1w   REG    8,7 1744379904  65603 /home/orastage/tdrs2.sdw_sdfm.sh.log (deleted)
expdp   29961 orastage    2w   REG    8,7 1744379904  65603 /home/orastage/tdrs2.sdw_sdfm.sh.log (deleted)
[root@corfcracrc201p home]#


command to get top memory utilised processess 
================================
ps -A --sort -rss -o comm,pmem | head -n 11



====================================
Show Users with High CPU Processing
====================================

column user_process format a30 heading "UserProcess(SID)"
column value format 999,999,999.99

select ss.username||'('||se.sid||')' user_process, value
     from v$session ss, v$sesstat se, v$statname sn
    where  se.statistic# = sn.statistic#
      and  name  like '%CPU used by this session%'
      and  se.sid = ss.sid
       and  ss.username is not null
     order  by substr(name,1,25), value desc
    /

output
========

UserProces           VALUE
---------- ---------------
SYS(586)         31,969.00
SCOS(119)         2,603.00
SCOS(80)          2,452.00
SCOS(14)          2,166.00
SCOS(703)         1,994.00
SCOS(68)          1,950.00
SCOS(768)         1,878.00
SCOS(716)         1,562.00
SCOS(638)         1,525.00
SCOS_READ(          960.00
SYS(469)            583.00

=====================
HIGH CPU 2nd query
=====================

Mem:  528493576k total, 108185952k used, 420307624k free,  1205780k buffers
Swap: 67111528k total,        0k used, 67111528k free, 84853384k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
  709 oraprod   25   0 16.0g 8.0g 7.9g R 100.3  1.6   8:46.04 oracle
 9584 oraprod   19   0 15.8g 9.3g 9.3g R 100.0  1.8 531:56.72 oracle
16914 oraprod   25   0 15.8g  10g   9g R 100.0  2.0 688:50.43 oracle
21523 oraprod   18   0 15.8g 9.3g 9.3g R 100.0  1.8 531:56.07 oracle

col SQL_TEXT for a50;
col USERNAME for a20;
col SPID for a15;
SELECT /*+ ordered */ p.spid, s.sid, s.serial#, s.username,
TO_CHAR(s.logon_time, 'mm-dd-yyyy hh24:mi') logon_time, s.last_call_et, st.value,
s.sql_hash_value, s.sql_address, sq.sql_text
FROM v$statname sn, v$sesstat st, v$process p, v$session s, v$sql sq
WHERE s.paddr=p.addr
AND s.sql_hash_value = sq.hash_value and s.sql_Address = sq.address
AND s.sid = st.sid
AND st.STATISTIC# = sn.statistic#
AND sn.NAME = 'CPU used by this session'
AND p.spid = &osPID ==> Enter os pid here from above top command
AND s.status = 'ACTIVE'
ORDER BY st.value desc;




To check all sessions (Connections) Happened from TOAD/SQLDEVLOPER/APPLIATION or etc.. to a perticular Database
=================================================================================================================
set lines 200 pages 300
col USERNAME for a10
col LOGON_TIME for a30
col SPID for a10
col MACHINE for a25
col PROGRAM for a30
col OSUSER for a10

select s.sid,s.serial#,s.username,s.osuser,s.status,s.server,to_char(s.logon_time,'DD-MON-YY/HH24.MI:SS') logon_time,p.spid,s.machine,s.program
from v$process p,v$session s
where ((s.type = 'USER') or (s.type = 'BACKGROUND' and s.program like '%SNP%'))
and p.addr = s.paddr
order by decode(status,'ACTIVE',2,1),logon_time;



Queries currently running on the database
================================
1) SELECT S.USERNAME, S.SID, S.SERIAL#, SQL_TEXT FROM   V$SESSION S,  V$SQLTEXT_WITH_NEWLINES T WHERE S.SQL_ID IS NOT NULL AND S.SQL_ID = T.SQL_ID ORDER BY S.SID,T.PIECE;

You can use the query presented by Yoann and you can also use v$sqltext instead of v$sqltext_with_newlines in this query. 

2) SELECT
  SST.VALUE CPU, S.USERNAME, S.SID, S.SERIAL#, SQL_TEXT
FROM 
  V$SESSION S,
  V$SQLTEXT_WITH_NEWLINES T,
  V$SESSTAT SST
WHERE S.SQL_ID IS NOT NULL
AND S.SQL_ID = T.SQL_ID
AND SST.SID = S.SID
AND SST.STATISTIC# = (SELECT STATISTIC# FROM V$STATNAME SN WHERE SN.NAME = 'CPU used by this session')
ORDER BY 1 DESC, S.SID,T.PIECE;


How to find out Which User is Running what SQL Query in Oracle database?
========================================================

SELECT 
SUBSTR(SS.USERNAME,1,8) USERNAME,
SS.OSUSER "USER",
AR.MODULE || ' @ ' || SS.machine CLIENT,
SS.PROCESS PID,
TO_CHAR(AR.LAST_LOAD_TIME, 'DD-Mon HH24:MM:SS') LOAD_TIME,
AR.DISK_READS DISK_READS,
AR.BUFFER_GETS BUFFER_GETS,
SUBSTR(SS.LOCKWAIT,1,10) LOCKWAIT,
W.EVENT EVENT,
SS.status,
AR.SQL_fullTEXT SQL
FROM V$SESSION_WAIT W,
V$SQLAREA AR,
V$SESSION SS, 
v$timer T
WHERE SS.SQL_ADDRESS = AR.ADDRESS
AND SS.SQL_HASH_VALUE = AR.HASH_VALUE
AND SS.SID = w.SID (+)
AND ss.STATUS = 'ACTIVE'
AND W.EVENT != 'client message'
ORDER BY  SS.LOCKWAIT ASC, SS.USERNAME, AR.DISK_READS DESC;

########################################
To findout Database full size - 1
########################################

SQL> select sum(bytes)/1024/1024 from dba_data_files;

SUM(BYTES)/1024/1024
--------------------
               43660

SQL> select sum(bytes)/1024/1024 from v$log;

SUM(BYTES)/1024/1024
--------------------
                6144


########################################
To findout Database full size - 2
########################################

select DataFiles.data_size+TempFiles.temp_size+RedoLogs.redo_size+ControlFile.controlfile_size "total_size in MB"
from
( select sum(bytes)/1024/1024 data_size from dba_data_files ) DataFiles,
( select nvl(sum(bytes),0)/1024/1024 temp_size from dba_temp_files ) TempFiles,
( select sum(bytes)/1024/1024 redo_size from sys.v_$log ) RedoLogs,
( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024 controlfile_size from v$controlfile) ControlFile;


#######################################
To findout Database USED size IN GB
######################################

select sum(bytes)/1024/1024/1024 from dba_segments;


#######################################
To findout TABLE  size IN GB
######################################

select sum(BYTES)/1024/1024/1024,SEGMENT_NAME,SEGMENT_TYPE FROM dba_segments where  SEGMENT_NAME='PRTB_XML_BAG' and OWNER='TEST_DBA' group by SEGMENT_NAME,SEGMENT_TYPE;


########################
13:View Database Size:
########################
select substr(to_char(sum(bytes)/1024/1024, '999,999,999.99'), 1, 15) "Total M BYTES", substr(to_char(sum(bytes)/1024/1024/1024, '999,999.99'), 1, 11) "Total G BYTES" from sys.dba_data_files;

 
##########################
14:View Database Usage:
#############################
select us.name Username,ts.name Tablespace,sum(seg.blocks*ts.blocksize)/1024 Space from sys.ts$ ts,sys.user$ us,sys.seg$ seg where seg.user# = us.user# and ts.ts# = seg.ts# group by us.name,ts.name;

###############################
To findout Schema size
###############################

select owner, sum(bytes)/1024/1024 from dba_segments group by owner;

###############################
To findout Segment size
###############################
col segment_name format a20
select segment_name,bytes "SIZE_BYTES",ceil(bytes / 1024 / 1024) "SIZE_MB" from dba_segments where  segment_name like '&obj_name';


#########################################
Check Database/Instance Startup Time
#########################################

select  INSTANCE_NAME, to_char(STARTUP_TIME,'dd-mon-yy:hh24:mi:ss') from v$instance;

INSTANCE_NAME    TO_CHAR(STARTUP_TI
---------------- ------------------
NYMERAQ2         15-sep-11:15:24:04



###################################
Object Count in Schema
###################################

SQL> select object_type,count(*) from dba_objects where owner='&Schema name' group by object_type order by 1;

####################################
TABLE ROW COUNT in Schema
####################################

SQL> select OWNER,TABLE_NAME,NUM_ROWS from dba_tables where owner='&Schema name' order by 2;





































#################################################
Oracle DBA Silver Bullets – Performance Queries 

23 Mar, 2011  Rupesh Oracle DBA, Oracle DBA Scripts 

Just thought to share few queries from my repository. It may be useful for all new DBAs. Of course these are quite old ones and you can do most of them through Enterprise Manager, still we DBAs always like command line  


Show sessions that are blocking each other :
================================================
select	'SID ' || l1.sid ||' is blocking  ' || l2.sid blocking
from	v$lock l1, v$lock l2
where	l1.block =1 and l2.request > 0
and	l1.id1=l2.id1
and	l1.id2=l2.id2
/Show locked objects :
set lines 100 pages 999
col username 	format a20
col sess_id 	format a10
col object	format a25
col mode_held	format a10
select	oracle_username || ' (' || s.osuser || ')' username
,	s.sid || ',' || s.serial# sess_id
,	owner || '.' ||	object_name object
,	object_type
,	decode(	l.block
	,	0, 'Not Blocking'
	,	1, 'Blocking'
	,	2, 'Global') status
,	decode(v.locked_mode
	,	0, 'None'
	,	1, 'Null'
	,	2, 'Row-S (SS)'
	,	3, 'Row-X (SX)'
	,	4, 'Share'
	,	5, 'S/Row-X (SSX)'
	,	6, 'Exclusive', TO_CHAR(lmode)) mode_held
from	v$locked_object v
,	dba_objects d
,	v$lock l
,	v$session s
where 	v.object_id = d.object_id
and 	v.object_id = l.id1
and 	v.session_id = s.sid
order by oracle_username
,	session_id



/Show which row is locked :
=====================================
select	do.object_name
,	row_wait_obj#
,	row_wait_file#
,	row_wait_block#
,	row_wait_row#
,	dbms_rowid.rowid_create (1, ROW_WAIT_OBJ#, ROW_WAIT_FILE#,
				ROW_WAIT_BLOCK#, ROW_WAIT_ROW#)
from	v$session s
,	dba_objects do
where	sid=&sid
and 	s.ROW_WAIT_OBJ# = do.OBJECT_ID

/
Then select the row with that rowid...

select * from <table> where rowid=<rowid>;List locks :
column lock_type format a12
column mode_held format a10
column mode_requested format a10
column blocking_others format a20
column username format a10
SELECT	session_id
,	lock_type
,	mode_held
,	mode_requested
,	blocking_others
,	lock_id1
FROM	dba_lock l
WHERE 	lock_type NOT IN ('Media Recovery', 'Redo Thread')


/Show all ddl locks in the system :
========================================
select	ses.username
,	ddl.session_id
,	ses.serial#
,	owner || '.' || ddl.name object
,	ddl.type
,	ddl.mode_held
from	dba_ddl_locks ddl
,	v$session ses
where	owner like '%userid%'
and	ddl.session_id = ses.sid


/Generate kill statement for ddl locking sessions :
========================================================
select    'alter system kill session ''' || ddl.session_id || ',' || ses.serial# || ''' immediate;'
from    dba_ddl_locks ddl
,    v$session ses
where    owner like '%userid%'
and    ddl.session_id = ses.sid


/Show currently exectuing sql :
=======================================
select sql_text
from v$sqlarea
where users_executing > 0


/Session statistics :
=========================================
select    sn.name
,    st.value
from    v$sesstat st
,    v$statname sn
where    st.STATISTIC# = sn.STATISTIC#
and    st.VALUE > 0
and    st.SID = &SID
order     by value desc


/Resource intensive sql :
=====================================
change 8192 to match block size

select sql_text
,      executions
,      to_char((((disk_reads+buffer_gets)/executions) * 8192)/1048576, '9,999,999,990.00')
 as total_gets_per_exec_mb
,      to_char((( disk_reads             /executions) * 8192)/1048576, '9,999,999,990.00')
 as disk_reads_per_exec_mb
,      to_char((( buffer_gets            /executions) * 8192)/1048576, '9,999,999,990.00')
 as buffer_gets_per_exec_mb
,      parsing_user_id
from   v$sqlarea
where  executions > 10
order by 6 desc


/File io stats :
===============================
Requires timed_statistics=true

set lines 80 pages 999
col fname heading "File Name" format a60
col sizemb heading "Size(Mb)" format 99,999
col phyrds heading "Reads" format 999,999,999
col readtim heading "Time" format 99.999
col phywrts heading "Writes" format 9,999,999
col writetim heading "Time" format 99.999
select     lower(name) fname
,          (bytes / 1048576) sizemb
,          phyrds
,    readtim
,          phywrts
,    writetim
from       v$datafile df
,          v$filestat fs
where      df.file# = fs.file#
order      by 1


/In session tracing :

To switch it on:
=====================
exec dbms_system.set_sql_trace_in_session (<sid>, <serial#>, true);

To switch it off:
======================
exec dbms_system.set_sql_trace_in_session (<sid>, <serial#>, false);switch on event 10046 :
To switch it on:

alter session set events '10046 trace name context forever, level 8'; 

To switch it off:
=======================
alter session set events '10046 trace name context off';
Note. use tkprof to interpret the results.Rows per block :
select    avg(row_count) avg
, max(row_count) max
, min(row_count) min
from      (
 select  count(*) row_count
 from    &table_name
 group   by substr(rowid, 1, 15)
 )


/Show the buffer cache advisory :
=======================================
Note. The current setting is halfway down and has a read factor of one.

set lines 100 pages 999
col est_mb format 99,999
col estd_physical_reads format 999,999,999,999,999
select    size_for_estimate est_mb
,    estd_physical_read_factor
,    estd_physical_reads
from    v$db_cache_advice
where    name = 'DEFAULT'
order by size_for_estimate


/db_cache_advice needs to be on for the above to work
=======================================================
alter system set db_cache_advice=on;




=============
  UNDO Tablespace 
=============

col time for a16 alias "Time"
select  to_char(begin_time,'DD/MM/YYYY HH24:MI')  time,
        round(unexpiredblks*8192/1024/1024,2)     "Unexpired Size (MB)",
        round(expiredblks*8192/1024/1024,2)       "Expired Size (MB)"
from    dba_hist_undostat
where   begin_time  >= to_date('27/09/2013 00:00','DD/MM/YYYY HH24:MI')
and     end_time    <= sysdate
order by 1;



Calculate UNDO_RETENTION  for given UNDO Tabespace 
================================================

You can choose to allocate a specific size for the UNDO tablespace and then set the UNDO_RETENTION parameter to an optimal value according to the UNDO size 
and the database activity. If your disk space is limited and you do not want to allocate more space than necessary to the UNDO tablespace, this is the way to proceed. 
The following query will help you to optimize the UNDO_RETENTION parameter: 


UNDO RETENTION = ACTUAL UNDO Tablespace SIZE / (UNDO_BLOCK_PER_SEC * DB_BLOCK_SIZE)
 

Because these following queries use the V$UNDOSTAT statistics, run the queries only after the database has been running with UNDO for a significant and representative time! 

Actual Undo Size
============== 

SELECT SUM(a.bytes) "UNDO_SIZE"
  FROM v$datafile a,
       v$tablespace b,
       dba_tablespaces c
 WHERE c.contents = 'UNDO'
   AND c.status = 'ONLINE'
   AND b.name = c.tablespace_name
   AND a.ts# = b.ts#; 

 UNDO_SIZE
----------
  209715200 

Undo Blocks per Second 
===================

SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
      "UNDO_BLOCK_PER_SEC"
  FROM v$undostat; 

UNDO_BLOCK_PER_SEC
------------------
        3.12166667 

DB Block Size 
===========

SELECT TO_NUMBER(value) "DB_BLOCK_SIZE [KByte]"
 FROM v$parameter
WHERE name = 'db_block_size'; 

DB_BLOCK_SIZE [Byte]
--------------------
                4096 

Optimal Undo Retention 

209'715'200 / (3.12166667 * 4'096) = 16'401 [Sec] 


Using Inline Views, you can do all in one query! 

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       ROUND((d.undo_size / (to_number(f.value) *
       g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
  FROM (
       SELECT SUM(a.bytes) undo_size
          FROM v$datafile a,
               v$tablespace b,
               dba_tablespaces c
         WHERE c.contents = 'UNDO'
           AND c.status = 'ONLINE'
           AND b.name = c.tablespace_name
           AND a.ts# = b.ts#
       ) d,
       v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
              undo_block_per_sec
         FROM v$undostat
       ) g
WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/ 

ACTUAL UNDO SIZE [MByte]
------------------------
200

UNDO RETENTION [Sec]
--------------------
10800

OPTIMAL UNDO RETENTION [Sec]
----------------------------
16401 


Calculate Needed UNDO Size for given Database Activity 
===========================================

If you are not limited by disk space, then it would be better to choose the UNDO_RETENTION time that is best for you (for FLASHBACK, etc.). 
Allocate the appropriate size to the UNDO tablespace according to the database activity: 

 

Again, all in one query: 

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
      "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size'
/

ACTUAL UNDO SIZE [MByte]
------------------------
200
UNDO RETENTION [Sec] 
--------------------
10800
NEEDED UNDO SIZE [MByte]
------------------------
131.695313

The previous query may return a "NEEDED UNDO SIZE" that is less than the "ACTUAL UNDO SIZE". 
If this is the case, you may be wasting space. You can choose to resize your UNDO tablespace to a lesser value or increase your UNDO_RETENTION parameter to use the additional space.

			=================================================
					UNDO Queries (Metalink)
			===================================================

1. To check the current size of the Undo tablespace:

select sum(a.bytes) as undo_size from v$datafile a, v$tablespace b, dba_tablespaces c where c.contents = 'undo' and c.status = 'online' 
and b.name = c.tablespace_name and a.ts# = b.ts#;

2. To check the free space (unallocated) space within Undo tablespace:

select sum(bytes)/1024/1024 "mb" from dba_free_space where tablespace_name ='<undo tablespace name>';

3.To Check the space available within the allocated Undo tablespace:

select tablespace_name , sum(blocks)*8/(1024)  reusable_space from dba_undo_extents where status='EXPIRED'  group by  tablespace_name;

4. To Check the space allocated in the Undo tablespace:

select tablespace_name , sum(blocks)*8/(1024)  space_in_use from dba_undo_extents where status IN ('ACTIVE','UNEXPIRED') group by  tablespace_name;


(Metalink - Good UNDO QUERY ) To find the max query length and the tuned_undo retention, run this SQL.
=====================================================================

set pagesize 25
set linesize 100
column UNXPSTEALCNT heading "# Unexpired|Stolen"
column EXPSTEALCNT heading "# Expired|Reused"
column SSOLDERRCNT heading "ORA-1555|Error"
column NOSPACEERRCNT heading "Out-Of-space|Error"
column MAXQUERYLEN heading "Max Query|Length"
select inst_id, to_char(begin_time,'MM/DD/YYYY HH24:MI') begin_time,UNXPSTEALCNT, EXPSTEALCNT , SSOLDERRCNT, NOSPACEERRCNT, MAXQUERYLEN, TUNED_UNDORETENTION
from gv$undostat order by inst_id, begin_time;

(Metalink - Good UNDO QUERY 2 ) To find the max query length and the tuned_undo retention, run this SQL.
=====================================================================

SET SERVEROUTPUT ON
SET LINES 600
ALTER SESSION SET NLS_DATE_FORMAT = 'DD/MM/YYYY HH24:MI:SS';

DECLARE
    v_analyse_start_time    DATE := SYSDATE - 7;
    v_analyse_end_time      DATE := SYSDATE;
    v_cur_dt                DATE;
    v_undo_info_ret         BOOLEAN;
    v_cur_undo_mb           NUMBER;
    v_undo_tbs_name         VARCHAR2(100);
    v_undo_tbs_size         NUMBER;
    v_undo_autoext          BOOLEAN;
    v_undo_retention        NUMBER(5);
    v_undo_guarantee        BOOLEAN;
    v_instance_number       NUMBER;
    v_undo_advisor_advice   VARCHAR2(100);
    v_undo_health_ret       NUMBER;
    v_problem               VARCHAR2(1000);
    v_recommendation        VARCHAR2(1000);
    v_rationale             VARCHAR2(1000);
    v_retention             NUMBER;
    v_utbsize               NUMBER;
    v_best_retention        NUMBER;
    v_longest_query         NUMBER;
    v_required_retention    NUMBER;
BEGIN
    select sysdate into v_cur_dt from dual;
    DBMS_OUTPUT.PUT_LINE(CHR(9));
    DBMS_OUTPUT.PUT_LINE('- Undo Analysis started at : ' || v_cur_dt || ' -');
    DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');

    v_undo_info_ret := DBMS_UNDO_ADV.UNDO_INFO(v_undo_tbs_name, v_undo_tbs_size, v_undo_autoext, v_undo_retention, v_undo_guarantee);
    select sum(bytes)/1024/1024 into v_cur_undo_mb from dba_data_files where tablespace_name = v_undo_tbs_name;

    DBMS_OUTPUT.PUT_LINE('NOTE:The following analysis is based upon the database workload during the period -');
    DBMS_OUTPUT.PUT_LINE('Begin Time : ' || v_analyse_start_time);
    DBMS_OUTPUT.PUT_LINE('End Time   : ' || v_analyse_end_time);
    
    DBMS_OUTPUT.PUT_LINE(CHR(9));
    DBMS_OUTPUT.PUT_LINE('Current Undo Configuration');
    DBMS_OUTPUT.PUT_LINE('--------------------------');
    DBMS_OUTPUT.PUT_LINE(RPAD('Current undo tablespace',55) || ' : ' || v_undo_tbs_name);
    DBMS_OUTPUT.PUT_LINE(RPAD('Current undo tablespace size (datafile size now) ',55) || ' : ' || v_cur_undo_mb || 'M');
    DBMS_OUTPUT.PUT_LINE(RPAD('Current undo tablespace size (consider autoextend) ',55) || ' : ' || v_undo_tbs_size || 'M');
    IF V_UNDO_AUTOEXT THEN
        DBMS_OUTPUT.PUT_LINE(RPAD('AUTOEXTEND for undo tablespace is',55) || ' : ON');  
    ELSE
        DBMS_OUTPUT.PUT_LINE(RPAD('AUTOEXTEND for undo tablespace is',55) || ' : OFF');  
    END IF;
    DBMS_OUTPUT.PUT_LINE(RPAD('Current undo retention',55) || ' : ' || v_undo_retention);

    IF v_undo_guarantee THEN
        DBMS_OUTPUT.PUT_LINE(RPAD('UNDO GUARANTEE is set to',55) || ' : TRUE');
    ELSE
        dbms_output.put_line(RPAD('UNDO GUARANTEE is set to',55) || ' : FALSE');
    END IF;
    DBMS_OUTPUT.PUT_LINE(CHR(9));

    SELECT instance_number INTO v_instance_number FROM V$INSTANCE;

    DBMS_OUTPUT.PUT_LINE('Undo Advisor Summary');
    DBMS_OUTPUT.PUT_LINE('---------------------------');

    v_undo_advisor_advice := dbms_undo_adv.undo_advisor(v_analyse_start_time, v_analyse_end_time, v_instance_number);
    DBMS_OUTPUT.PUT_LINE(v_undo_advisor_advice);

    DBMS_OUTPUT.PUT_LINE(CHR(9));
    DBMS_OUTPUT.PUT_LINE('Undo Space Recommendation');
    DBMS_OUTPUT.PUT_LINE('-------------------------');

    v_undo_health_ret := dbms_undo_adv.undo_health(v_analyse_start_time, v_analyse_end_time, v_problem, v_recommendation, v_rationale, v_retention, v_utbsize);
    IF v_undo_health_ret > 0 THEN
        DBMS_OUTPUT.PUT_LINE('Minimum Recommendation           : ' || v_recommendation);
        DBMS_OUTPUT.PUT_LINE('Rationale                        : ' || v_rationale);
        DBMS_OUTPUT.PUT_LINE('Recommended Undo Tablespace Size : ' || v_utbsize || 'M');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Allocated undo space is sufficient for the current workload.');
    END IF;
    
    SELECT dbms_undo_adv.best_possible_retention(v_analyse_start_time, v_analyse_end_time) into v_best_retention FROM dual;
    SELECT dbms_undo_adv.longest_query(v_analyse_start_time, v_analyse_end_time) into v_longest_query FROM dual;
    SELECT dbms_undo_adv.required_retention(v_analyse_start_time, v_analyse_end_time) into v_required_retention FROM dual;

    DBMS_OUTPUT.PUT_LINE(CHR(9));
    DBMS_OUTPUT.PUT_LINE('Retention Recommendation');
    DBMS_OUTPUT.PUT_LINE('------------------------');
    DBMS_OUTPUT.PUT_LINE(RPAD('The best possible retention with current configuration is ',60) || ' : ' || v_best_retention || ' Seconds');
    DBMS_OUTPUT.PUT_LINE(RPAD('The longest running query ran for ',60) || ' : ' || v_longest_query || ' Seconds');
    DBMS_OUTPUT.PUT_LINE(RPAD('The undo retention required to avoid errors is ',60) || ' : ' || v_required_retention || ' Seconds');

END;
/




======================
Temporary Tablespace
======================

=====================================================================
Direct path read

SELECT p1 "file#", p2 "block#", p3 "class#" FROM gv$session_wait WHERE event = 'direct path read temp';

SELECT relative_fno, owner, segment_name, segment_type FROM dba_extents WHERE file_id = &file AND &block BETWEEN block_id AND block_id + &blocks – 1;

=======================================================================

select property_value from database_properties where property_name ='DEFAULT_TEMP_TABLESPACE';


How Can Temporary Segment Usage Be Monitored Over Time? (Doc ID 364417.1) (Dynamic monitoring)


SQL> SELECT TABLESPACE_NAME,SUM(BYTES_USED/1024/1024),SUM(BYTES_FREE/1024/1024) FROM v$TEMP_SPACE_HEADER GROUP BY TABLESPACE_NAME;

SQL> CREATE USER scott DEFAULT TABLESPACE data TEMPORARY TABLESPACE temp;

SQL> ALTER USER scott TEMPORARY TABLESPACE temp;

SQL> SELECT tablespace_name, SUM(bytes_used), SUM(bytes_free) FROM   V$temp_space_header; --> To check Space

select round((SUM(BYTES_FREE)/(SUM(bytes_used)+SUM(bytes_free)))*100) "Free percentage" from V$temp_space_header;

SELECT * FROM DATABASE_PROPERTIES where PROPERTY_NAME='DEFAULT_TEMP_TABLESPACE'; ==> To check default temp tablespace

QL> ALTER DATABASE TEMPFILE '/oradata/temp02.dbf' DROP INCLUDING DATAFILES;

SQL> ALTER TABLESPACE temp ADD TEMPFILE '/oradata/temp03.dbf' SIZE 100M;

SQL> CREATE TEMPORARY TABLESPACE temp 
      TEMPFILE '/oradata/mytemp_01.tmp' SIZE 20M
      EXTENT MANAGEMENT LOCAL UNIFORM SIZE 16M;


select a.TABLESPACE_NAME,b.Total_MB,  b.Total_MB - round(a.used_blocks*8/1024) Current_Free_MB,
       round(used_blocks*8/1024)                Current_Used_MB,
      round(max_used_blocks*8/1024)             Max_used_MB
from gv$sort_segment a,
 (select round(sum(bytes)/1024/1024) Total_MB from dba_temp_files ) b;

  TOTAL_MB CURRENT_FREE_MB CURRENT_USED_MB MAX_USED_MB
---------- --------------- --------------- -----------
     46166           44188            1978       32262
     46166           22320           23846       41925


SELECT s.sid, s.username, u.tablespace, s.sql_hash_value||'/'||u.sqlhash hash_value, u.segtype, u.contents, u.blocks FROM gv$session s, gv$tempseg_usage u WHERE s.saddr=u.session_addr order by u.blocks;

       SID USERNAME        TABLESPACE      HASH_VALUE                                                                        SEGTYPE   CONTENTS      BLOCKS
---------- --------------- --------------- --------------------------------------------------------------------------------- --------- --------- ----------
       216                 TEMP            0/536973926                                                                       LOB_DATA  TEMPORARY        128
       216 STG_TEL_SF      TEMP            0/536973926                                                                       LOB_DATA  TEMPORARY        128
       351 BRO_ADM         TEMP            1473051908/3831480779                                                             LOB_DATA  TEMPORARY        128
       321                 TEMP            0/1259855359                                                                      LOB_DATA  TEMPORARY       1024
       321 EISDBA          TEMP            0/1259855359                                                                      LOB_DATA  TEMPORARY       1024
       236 BRO_ADM         TEMP            971062077/2982142955                                                              LOB_DATA  TEMPORARY       1920
       236 STG_S3          TEMP            0/2982142955                                                                      LOB_DATA  TEMPORARY       1920
       296 BRO_ADM         TEMP            1141779750/1570213724                                                             SORT      TEMPORARY     252544
       296 DBSNMP          TEMP            0/1570213724                                                                      SORT      TEMPORARY     252544


enter above SID and Username in below query
===============================
select hash_value, sorts, rows_processed/executions from gv$sql where hash_value in (select hash_value from v$open_cursor where sid=&sid) and sorts > 0 and PARSING_SCHEMA_NAME='&enter_user' order by rows_processed/executions;

Who is using my TEMP tablespace
=======================

SELECT   b.TABLESPACE
       , b.segfile#
       , b.segblk#
       , ROUND (  (  ( b.blocks * p.VALUE ) / 1024 / 1024 ), 2 ) size_mb
       , a.SID
       , a.serial#
       , a.username
       , a.osuser
       , a.program
       , a.status
    FROM gv$session a
       , gv$sort_usage b
       , gv$process c
       , gv$parameter p
   WHERE p.NAME = 'db_block_size'
     AND a.saddr = b.session_addr
     AND a.paddr = c.addr
ORDER BY a.SID,b.TABLESPACE
       , b.segfile#
       , b.segblk#
       , b.blocks;





SELECT A.tablespace_name tablespace, D.mb_total, SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free FROM  gv$sort_segment A, (SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total  FROM gv$tablespace B, gv$tempfile C WHERE  B.ts#= C.ts#  GROUP BY B.name, C.block_size  ) D WHERE  A.tablespace_name = D.name GROUP by A.tablespace_name, D.mb_total;
 
and returns:

TABLESPACE     MB_TOTAL    MB_USED    MB_FREE
------------------------------- ----------    ----------            ----------
TEMP                         512           0                 512

==================================
Query from METALINK For TEMP USAGE
==================================

https://orainternals.wordpress.com/2012/02/13/temporary-tablespaces-in-rac/ ==> RAC Temp issue

col USERNAME for a10;
col USERNAME for a15;
col OSUSER for a15;
col TABLESPACE for a10;
col SQL_TEXT for a80;

SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks, c.sql_text
FROM gv$session a, gv$tempseg_usage b, gv$sqlarea c
WHERE a.saddr = b.session_addr
AND c.address= a.sql_address
AND c.hash_value = a.sql_hash_value
ORDER BY b.tablespace, b.blocks;

USERNAME               SID    SERIAL# OSUSER          TABLESPACE     BLOCKS SQL_TEXT
--------------- ---------- ---------- --------------- ---------- ---------- --------------------------------------------------------------------------------
SYS                   1779      41061 oraprod         TEMP4             128 SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks, c.sql_tex
                                                                            t FROM v$session a, v$tempseg_usage b, v$sqlarea c WHERE a.saddr = b.session_add
                                                                            r AND c.address= a.sql_address AND c.hash_value = a.sql_hash_value ORDER BY b.ta
                                                                            blespace, b.blocks



More from metalink to debug temp issue
=============================

select inst_id, tablespace_name, round((total_blocks*8192)/(1024*1024*1024),2) "Space(GB)"
from gv$sort_segment
where tablespace_name='TEMP'
order by 1;

INST_ID  TABLESPACE_NAME        Space(GB)
---------- ------------------------------ ----------
1           TEMP                           33.46
2           TEMP                        1118.79   <<<<very unbalanced
3           TEMP                           33.28

Collect the information every few seconds:
1. select  * from gv$sort_segment
2. select sum(bytes), owner from gv$temp_extent_map group by owner;
3. select inst_id, blocks_cached, blocks_used, extents_cached, extents_used from GV$TEMP_EXTENT_POOL;



select
        a.tablespace_name, round(sum(a.bytes/1024/1024), 0) "Size [MB]",
        NVL(round(sum(b.bytes/1024/1024), 0), 0) "Free [MB]",
        round(NVL(sum(b.bytes), 0) / sum(a.bytes) * 100, 0) "pct free",
        decode(max(c.contents) || nvl(d.cnt, 0),
        'PERMANENT0', 'Data', 'TEMPORARY0', 'Temp', 'Roll') "Type"
from
        dba_temp_files a,
        (select file_id, sum(bytes) bytes from dba_free_space
        group by file_id) b,
        dba_tablespaces c,
        (select count(*) cnt, tablespace_name from dba_rollback_segs
        where tablespace_name != 'SYSTEM' group by tablespace_name) d
where
        a.file_id = b.file_id (+)
        and a.tablespace_name = c.tablespace_name
        and a.tablespace_name = d.tablespace_name (+)
group by
        a.tablespace_name, c.tablespace_name, d.tablespace_name, d.cnt
order by
        4 desc
;

TABLESPACE_NAME                 Size [MB]  Free [MB]   pct free Type
------------------------------ ---------- ---------- ---------- ----
TEMP                                 6500       8365        129 Temp



Try to check

SQL> select TABLESPACE_NAME,TOTAL_BLOCKS,USED_BLOCKS,FREE_BLOCKS from v$sort_segment;

TABLESPACE_NAME                 TOTAL_BLOCKS USED_BLOCKS FREE_BLOCKS
------------------------------- ------------ ----------- -----------
TEMP                                       0           0           0
TEMP01                                 55808         128       55680

====================================================================================
Dynamic query To change temporary tablespace of users from other tablespaces to TEMP
====================================================================================

select 'alter user ' || username || ' temporary tablespace temp;'  from dba_users where TEMPORARY_TABLESPACE = 'TEMP1';
select 'alter user ' || username || ' temporary tablespace temp;'  from dba_users where TEMPORARY_TABLESPACE = 'TEMP2'; 



and use the below query to find the queries which is using temporary segements apart from the query which u mentioned Above..

col USERNAME for a20;
col OSUSER for a10;
col TABLESPACE for a10;
col SQL_TEXT for a70;
SELECT a.username, a.sid, a.serial#, a.osuser, b.tablespace, b.blocks, c.sql_text
FROM v$session a, v$tempseg_usage b, v$sqlarea c
WHERE a.saddr = b.session_addr
AND c.address= a.sql_address
AND c.hash_value = a.sql_hash_value
ORDER BY b.tablespace, b.blocks;


the problem is that ORACLE is unable to allocate free space in the TEMP segment.

Note1: (I read somewhere that...) Generally ORACLE (8+) does a defragmentation of the temp space in some (rare) time intervals but ONLY IF you set the PCT_INCREASE Parameter to a value > 0%. 
Nevertheless the default value of 50% is (in my opinion) much to high. So, e.g. set this value to 1%.

Note2: The TEMP tablespace should always be set to "TEMPORARY"


The reason for YOUR problem can be one of the following:

1. there is actually no free space available

ACTION: let your DBA allocate more space to the TEMP segment, or wait until other user activity has terminated (which might free up some temp space), 
or wait until the next restart of the database which will as well re-initialize the temp space.

2. there is enough free space available, but you have a setting of the PCT_INCREASE parameter of the TEMP tablespace where the database 
will try to allocate a much larger block (which is NOT available).

ACTION 1: see 1.

ACTION 2: let your DBA set the PCT_INCREASE parameter to a smaller value

3. there is enough free space available, but the largest free block is too small

ACTION: let your DBA defragment the tablespace (or restart the database)


========================
Temporary tablespace queries
=======================

Monitoring Temporary Space Usage
============================

The following query displays information about all sort segments in the database. 
(As a reminder, we use the term “sort segment” to refer to a temporary segment in a temporary tablespace.) 
Typically, Oracle will create a new sort segment the very first time a sort to disk occurs in a new temporary tablespace. 
The sort segment will grow as needed, but it will not shrink and will not go away after all sorts to disk are completed. 
A database with one temporary tablespace will typically have just one sort segment.
    
SELECT   A.tablespace_name tablespace, D.mb_total,
             SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,
             D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free
    FROM     gv$sort_segment A,
             (
             SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
             FROM     gv$tablespace B, gv$tempfile C
             WHERE    B.ts#= C.ts#
             GROUP BY B.name, C.block_size
             ) D
    WHERE    A.tablespace_name = D.name
    GROUP by A.tablespace_name, D.mb_total;

The query displays for each sort segment in the database the tablespace the segment resides in, 
the size of the tablespace, the amount of space within the sort segment that is currently in use, and the amount of space available. Sample output from this query is as follows:

    TABLESPACE                        MB_TOTAL    MB_USED    MB_FREE
    ------------------------------- ---------- ---------- ----------
    TEMP                                 10000          9       9991



Sort Space Usage by Session
=========================

The following query displays information about each database session that is using space in a sort segment. 
Although one session may have many sort operations active at once, this query summarizes the information by session. 
This query will need slight modification to run on Oracle 8i databases, since the dba_tablespaces view did not have a block_size column in Oracle 8i.
   
 SELECT   S.sid || ',' || S.serial# sid_serial, S.username, S.osuser, P.spid, S.module,
             S.program, SUM (T.blocks) * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,
             COUNT(*) sort_ops
    FROM     v$sort_usage T, v$session S, dba_tablespaces TBS, v$process P
    WHERE    T.session_addr = S.saddr
    AND      S.paddr = P.addr
    AND      T.tablespace = TBS.tablespace_name
    GROUP BY S.sid, S.serial#, S.username, S.osuser, P.spid, S.module,
             S.program, TBS.block_size, T.tablespace
    ORDER BY sid_serial;


    SID_SERIAL USERNAME OSUSER SPID MODULE PROGRAM   MB_USED TABLESPACE SORT_OPS
    ---------- -------- ------ ---- ------ --------- ------- ---------- --------
    33,16998   RPK_APP  rpk    3061 inv    httpd@db1       9 TEMP              2



Sort Space Usage by Statement
==========================

The following query displays information about each statement that is using space in a sort segment. 
This query will need slight modification to run on Oracle 8i databases, since the dba_tablespaces view did not have a block_size column in Oracle 8i.
    
SELECT   S.sid || ',' || S.serial# sid_serial, S.username,
             T.blocks * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,
             T.sqladdr address, Q.hash_value, Q.sql_text
    FROM     v$sort_usage T, v$session S, v$sqlarea Q, dba_tablespaces TBS
    WHERE    T.session_addr = S.saddr
    AND      T.sqladdr = Q.address (+)
    AND      T.tablespace = TBS.tablespace_name
    ORDER BY S.sid;

    SID_SERIAL USERNAME MB_USED TABLESPACE ADDRESS          HASH_VALUE
    ---------- -------- ------- ---------- ---------------- ----------
    SQL_TEXT
    --------------------------------------------------------------------------------
    33,16998   RPK_APP        8 TEMP       000000038865B058 3641290170
    SELECT * FROM NOTIFY_MESSAGES NM WHERE NM.AWAITING_SENDING = 'y' AND NOT EXISTS
    ( SELECT 1 FROM NOTIFY_MESSAGE_GROUPS NMG WHERE NMG.MESSAGE_GROUP_ID = NM.MESSAG
    E_GROUP_ID AND NMG.INCOMPLETE = 'y' ) ORDER BY NM.NOTIFY_MESSAGE_ID
    33,16998   RPK_APP        1 TEMP       00000003839FFE20 1874671316
    select * from rpk_stat where sample_group_id = :b1 order by stat#, seq#

===================================== 
— Temp segment usage per session.—
=====================================

SELECT S.sid || ',' || S.serial# sid_serial, S.username, S.osuser, P.spid, S.module,
P.program, SUM (T.blocks) * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,
COUNT(*) statements
FROM v$sort_usage T, v$session S, dba_tablespaces TBS, v$process P
WHERE T.session_addr = S.saddr
AND S.paddr = P.addr
AND T.tablespace = TBS.tablespace_name
GROUP BY S.sid, S.serial#, S.username, S.osuser, P.spid, S.module,
P.program, TBS.block_size, T.tablespace
ORDER BY sid_serial;







===================================
Blocking Sessions
===================================

See what SQL users are running on the system
----------------------------------------------------
col sql_text for a70;
select a.sid, a.serial#,a.osuser,a.username,b.sql_text from v$session a, v$sqlarea b  where a.sql_address=b.address and a.username='GRUMPY';
 
       SID    SERIAL# SQL_TEXT
 
---------- ---------- ----------------------------------------------
       122      61521 select count(*) from gen_person where gen_person_id=95000

See what session is blocking other sessions
-------------------------------------------

select  blocking_session,  sid,  serial#,  wait_class,  seconds_in_wait from  gv$session where  blocking_session is not NULL order by  blocking_session;
 
BLOCKING_SESSION        SID    SERIAL# WAIT_CLASS           SECONDS_IN_WAIT
---------------- ---------- ---------- -------------------- --------
             148        135      61521 Idle                              64



FreeSpace per Datafile
====================

set pages 1000
set lines 132
set trims on
col tablespace_name format a15            heading "Tabsp Name"
col file_name       format a40            heading "File Name"
col total_size      format 999,999.00     heading "Size MB"
col free_space      format 999,999.00     heading "Free MB"
col pct_used        format 999.00         heading "%|Used"

clear breaks

select df.tablespace_name
,      df.file_name
,      df.bytes/1024/1024                        total_size
,      nvl(fr.bytes/1024/1024,0)                 free_space
,      ((df.bytes-nvl(fr.bytes,0))/df.bytes)*100 pct_used
from   (select sum(bytes) bytes
        ,      file_id
        from   dba_free_space
        group by file_id)     fr
,       dba_data_files        df
where df.file_id = fr.file_id(+)
order by 1, df.file_id
/


====================================================================================================================================

From the website: http://code.geekinterview.com/oracle/database-health-check.html


SET linesize 132
SET pagesize 1000
spool report.txt
prompt #### Up TIME ####
SELECT 'Hostname      : ' || host_name
      ,'Instance Name : ' || instance_name
 
      ,'Started At    : ' || TO_CHAR(startup_time,'DD-MON-YYYY HH24:MI:SS') stime
 
      ,'Uptime        : ' || FLOOR(SYSDATE - startup_time) || ' days(s) ' ||
 
       TRUNC( 24*((sysdate-startup_time) -
 
       TRUNC(sysdate-startup_time))) || ' hour(s) ' ||
 
       MOD(TRUNC(1440*((sysdate-startup_time) -
 
       TRUNC(sysdate-startup_time))), 60) ||' minute(s) ' ||
 
       MOD(TRUNC(86400*((sysdate-startup_time) -
 
       TRUNC(sysdate-startup_time))), 60) ||' seconds' uptime
 
FROM sys.v_$instance;

prompt ################################################################################
prompt .>>>>>>    Object status
SELECT object_type,status,COUNT(*) cnt FROM user_objects  GROUP BY  object_type,status;
prompt
prompt
prompt ################################################################################
prompt .>>>>>>  Invalid objects
SELECT owner, object_type, SUBSTR(object_name,1,30) object_name
FROM sys.dba_objects
WHERE status='INVALID'
ORDER BY object_type;
prompt
prompt
prompt ################################################################################
prompt .>>>>>>    Recover files
SELECT * FROM sys.v_$recover_file;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> partitioned TABLE
SELECT table_name FROM user_tables WHERE partitioned='YES';
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Free SPACE IN TABLESPACE
SELECT tablespace_name,SUM(bytes/1024/1024) FROM sys.dba_free_space GROUP BY tablespace_name;
prompt
prompt
prompt ################################################################################
prompt .>>>>>>Max Extents Status
SELECT segment_name, segment_type, extents, max_extents FROM sys.dba_segments WHERE max_extents-extents<100;
prompt
prompt
prompt ################################################################################
prompt .>>>>>>  ANY partitioned Object approaching TO MAX extents
SELECT PARTITION_NAME,EXTENTS,MAX_EXTENTS,NEXT_EXTENT,max_extents-NVL(next_extent,0) FROM sys.dba_segments
WHERE max_extents-NVL(next_extent,0) < 1000
AND partition_name IS NOT NULL;
prompt
prompt
prompt ################################################################################
prompt .>>>>>>  Block Contention
SELECT class,SUM(COUNT) total_waits, SUM(TIME) total_time FROM v$waitstat GROUP BY class;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Latch Contention
SELECT a.name,100.*b.sleeps/b.gets ratio1,100.*b.immediate_misses/DECODE((b.immediate_misses+b.immediate_gets),0,1) ratio2
FROM v$latchname a, v$latch b WHERE
a.latch# = b.latch# AND b.sleeps > 0;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Top 10 Queries USING more disk reads
SELECT disk_reads,sql_text FROM v$sqlarea WHERE disk_reads>10000 AND ROWNUM < 11 ORDER BY disk_reads DESC;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Top 10 Queries USING more buffer reads
SELECT  buffer_gets,sql_text FROM v$sqlarea WHERE buffer_gets>10000 AND ROWNUM < 11 ORDER BY buffer_gets DESC;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> buffer cache hit ratio
SELECT (1- (SUM(DECODE(a.name,'physical reads',VALUE,0)))/
 
        (SUM(DECODE(a.name,'db block gets',VALUE,0)) +
 
        SUM(DECODE(a.name,'consistent gets',VALUE,0)))) * 100 pct
 
        FROM v$sysstat a;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Reloads/Pins IN v$librarycache
SELECT SUM(pins) "executions",SUM(reloads) "cache Misses",SUM(reloads)/SUM(pins)*100 "Ratio" FROM v$librarycache;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Get miss ratio FROM v$rowcache  
SELECT (SUM(getmisses)/SUM(gets)) * 100 "Hit Ratio" FROM v$rowcache;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> Redo LOG SPACE request ratio IN v$systat
SELECT (req.VALUE*5000)/entries.VALUE "ratio"
FROM v$sysstat req,v$sysstat entries
WHERE req.name='redo log space requests' AND entries.name='redo entries' ;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> RBS Contention
SELECT SUM(waits)/SUM(gets)*100 FROM v$rollstat;
prompt
prompt
prompt ################################################################################
prompt .>>>>>> sorts stats
SELECT * FROM v$sysstat WHERE name LIKE '%sorts%';
prompt
prompt
prompt ################################################################################
prompt .>>>>>> datafiles I/O
SELECT name, phyrds, phywrts FROM v$datafile df, v$filestat fs WHERE df.FILE# = fs.FILE# ORDER BY phyrds;  
prompt
prompt
prompt
prompt
spool off


=================================================================================================================================


Check DB JOBS 
----------------

SET LINESIZE 299
SET PAGESIZE 999
SET VERIFY   OFF

COLUMN job        FORMAT 999999   HEADING 'Job ID'
COLUMN username   FORMAT a15   HEADING 'User'
COLUMN what       FORMAT a30   HEADING 'What'
COLUMN next_date  For a20      HEADING 'Next Run Date'
COLUMN interval   FORMAT a30   HEADING 'Interval'
COLUMN last_date  for a20             HEADING 'Last Run Date'
COLUMN failures   for 99999999             HEADING 'Failures'
COLUMN broken     FORMAT a7    HEADING 'Broken?'

SELECT
    job
  , log_user username
  , what
  , TO_CHAR(next_date, 'DD-MON-YYYY HH24:MI:SS') next_date
  , interval
  , TO_CHAR(last_date, 'DD-MON-YYYY HH24:MI:SS') last_date
  , failures
  , broken
FROM
    dba_jobs;
============================================================================================================================


This script generates the alter user statements that set the user passwords to the current ones, without knowing it. 
------------------------------------------------------------------------------------------------------------------

SQL> connect USER01/xxxxxx
ERROR:
ORA-28001: the password has expired

SQL> connect / as sysdba
Connected.
SQL> select 'alter user "'||username||'" identified by values '''||extract(xmltype(dbms_metadata.get_xml('USER',username)),'//USER_T/PASSWORD/text()').getStringVal()||''';'  statement from dba_users 
where account_status like '%EXPIRED%' order by expiry_date; 

STATEMENT
--------------------------------------------------------------------
alter user "USER01" identified by values '7EFA03EC7EA6B86F';
alter user "USER02" identified by values '71E677F036AD56E5';

SQL> alter user "USER01" identified by values '7EFA03EC7EA6B86F';
User altered.

SQL> connect USER01/xxxxxx
Connected.


###################################
Oracle Data Dictionary Details
###################################

SQL> DESC DICT
Nombre                                    ?Nulo?   Tipo
—————————————– ——– —————————-
TABLE_NAME                                         VARCHAR2(30)
COMMENTS                                           VARCHAR2(4000)

SQL>  SELECT TABLE_NAME FROM DICT WHERE TABLE_NAME LIKE ‘%LINK%’;

TABLE_NAME
——————————
USER_DB_LINKS
ALL_DB_LINKS
DBA_DB_LINKS
V$DBLINK
GV$DBLINK

SQL> Grant Select_catalog_role to desdba

#######################################3
Monitoring import speed
########################################

select
   substr(sql_text,instr(sql_text,'INTO "'),30) table_name,
   rows_processed,
   round((sysdate-
    to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60,1) minutes,
   trunc(rows_processed/
    ((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60)) rows_per_minute
from  
   sys.v_$sqlarea
where 
   sql_text like 'INSERT %INTO "%'
and 
   command_type = 2
and 
   open_versions > 0;


Data pump import job monitoring
====================== 
col OPNAME for a20;
col MESSAGE for a40;
col USERNAME for a20;
select username,opname,target_desc,sofar,time_remaining/3600 hrs,totalwork,message from V$SESSION_LONGOPS where sofar <> totalwork;


###################################################
RAM Information on different OS
###################################################

Display RAM Size on DE C-Unix
-----------------------------
In DEC-Unix, you can use the uerf command in conjunction with grep to display memory size. For example:

>uerf -r 300 | grep -i mem

Display RAM Size on HP-UX
---------------------------
>dmesg

Display RAM Size on AIX
-------------------------
>lsdev -C|grep mem

mem0       Available 00-00           Memory

Here you can see that mem0 is the name of the memory device. Now that you have the name, you can issue the lsattr –El command to see the amount of memory on the server. In the following example, the server has 3 gigabytes of RAM installed:

>lsattr -El mem0

size     3064 Total amount of physical memory in Mbytes goodsize 3064 Amount of usable physical memory in Mbytes

You must issue the lsattr –El command separately for each memory device.

Display RAM size on Solaris
----------------------------
The prtconf command can also be used on all Solaris servers to quickly see the amount of available memory.

>prtconf|grep -i mem

Memory size: 2048 Megabytes

    memory (driver not attached)

    virtual-memory (driver not attached)

Display RAM size in Linux
-------------------------
In Linux the free command can be used to quickly display the amount of RAM memory on the server.

>free

             total       used       free     shared    buffers     cached

Mem:       3728668     504688    3223980      41316     430072      29440

-/+ buffers/cache:      45176    3683492

Swap:       265032        608     264424


########################################
Show SQL Statements Currently Running
########################################

COLUMN userID FORMAT A14
COLUMN sql_text FORMAT A65

BREAK ON userID SKIP 2

SET pagesize 0

SELECT s.schemaname||'('||TO_CHAR (s.sid)||')' userID,t.sql_text
FROM   sys.v$session s,sys.v$sqltext t
WHERE  t.address = s.sql_address
ORDER BY s.sid,t.piece
/

##############################
Show the Size of Database Objects
##############################

COLUMN segment_name FORMAT A30
COLUMN segment_type FORMAT A12
COLUMN extents FORMAT 9999999

SELECT segment_name,segment_type,extents,bytes,
       ROUND(bytes/(1024*1024),1) MBytes
FROM   user_segments
ORDER BY segment_name
/

##############################
Show Indexes on a Table
##############################
BREAK ON index_name SKIP 1 ON uniqueness

SELECT c.index_name,i.uniqueness,c.column_name
FROM   user_indexes i,user_ind_columns c
WHERE  i.table_name = upper ('&table')
AND    i.index_name = c.index_name
ORDER BY c.index_name,c.column_position
/

##########################################
TO KNOW ORACLE_HOME WITH SQL QUERY
##########################################

SQL> select substr(file_spec,   1,   instr(file_spec,   '/',   -1,   2) -1) from dba_libraries where library_name = 'DBMS_SUMADV_LIB';

SUBSTR(FILE_SPEC,1,INSTR(FILE_SPEC,'/',-1,2)-1)
--------------------------------------------------------------------------------
/data/oracle/product/10.2.0.4

######################################################
Rebuilding index partitions / subpartitions with corrupted block
######################################################

This procedure assumes you had this error (corrupted block in index partition):

ORA-01578: ORACLE data block corrupted (file # 459, block # 15)
ORA-01110: data file 459: '/path/to/datafile.dbf'
ORA-26040: Data block was loaded using the NOLOGGING option

1. Find out which partition has corrupted block

select distinct partition_name, index_name
from dba_ind_subpartitions
where subpartition_name in
	(
	select partition_name
	from dba_segments
	where tablespace_name in
		(
		select tablespace_name 
		from dba_data_files 
		where file_name = '/path/to/datafile.dbf'
		)
	)
/

2. Mark the index partition unusable

SQLPLUS> ALTER INDEX schema_name.index_name MODIFY PARTITION partition_name UNUSABLE;

3. Re-build index partition

If it's not a composite range partition you can simply do the following:

SQLPLUS> ALTER INDEX schema_name.index_name REBUILD PARTITION partition_name;

Otherwise, if it is a composite range partition you will get the following error:

ORA-14287: cannot REBUILD a partition of a Composite Range partitioned index

What you have to do is to rebuild each subpartition at a time. Here's the SQL script for
rebuilding subpartitions:

set head off pagesize 0 linesize 100

select 'ALTER INDEX ' || index_owner || '.' || index_name || ' REBUILD SUBPARTITION ' ||
subpartition_name || ';'
from dba_ind_subpartitions
where subpartition_name in
	(
	select partition_name
	from dba_segments
	where tablespace_name in
		(
		select tablespace_name 
		from dba_data_files 
		where file_name = '/path/to/datafile.dbf'
		)
	)
/

Copy and paste the commands to sqlplus or spool it to file if there are many subpartitions.

#################################################################
Rebuilding unusable indexes, index partitions, and index subpartitions.
####################################################################

select 'alter index '||owner||'.'||index_name||' rebuild;' from dba_indexes where status='UNUSABLE';
select 'alter index '||index_owner||'.'||index_name||' rebuild partition '||partition_name||';' from dba_ind_partitions where status='UNUSABLE';
select 'alter index '||index_owner||'.'||index_name||' rebuild subpartition '||subpartition_name||';' from dba_ind_subpartitions where status='UNUSABLE'; 


SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLESPACE_NAME
  FROM DBA_TAB_SUBPARTITIONS
  WHERE TABLE_NAME='QUARTERLY_REGIONAL_SALES'
  ORDER BY PARTITION_NAME;

######################
Check Alias
#####################

Can you kindly confirm, whether the below will be taken care as part of the CPU Upgrade by your team?.
 
1. "/etc/hosts" change:
 
 
Existing entry:  10.232.227.4 loncaaapltu1.uk.db.com loncaaapltu1
New   entry:    10.236.33.93  loncaaapltu1.uk.db.com  loncaaapltu1
2. Alias names tied to the IP addresses.
 
Eg:
C:\> nslookup lncaaau2.uk.db.com
Non-authoritative answer:
Name:    loncaaapltu1.uk.db.com
Address:  10.232.227.4
Aliases:  lncaaau2.uk.db.com
 
3. Database shutdown and restart as part of pre and post activity.
 
Look forward to hear from you.


#########################################3
To know the current PSU (PATCH SET UPDATE)
##########################################
col ACTION_TIME for a40;
col COMMENTS for a50;
col ACTION for a10;
col NAMESPACE for a20;
col VERSION for a10;
col BUNDLE_SERIES for a10;
col COMMENTS for a30;
col DESCRIPTION for a40;

select * from sys.registry$history; 

select * from dba_registry_history;

select PATCH_ID,patch_uid,ACTION,STATUS,ACTION_TIME,DESCRIPTION from dba_registry_sqlpatch order by ACTION_TIME desc;


ACTION_TIME                              ACTION     NAMESPACE  VERSION                                ID COMMENTS                       BUNDLE_SER
---------------------------------------- ---------- ---------- ------------------------------ ---------- ------------------------------ ----------
23-FEB-12 12.08.45.344485 PM             APPLY      SERVER     10.2.0.4                                7 PSU 10.2.0.4.11                OPSU
23-FEB-12 12.18.00.661672 PM             CPU                                                     6452863 view recompilation
15-MAR-12 11.58.35.275608 AM             VIEW RECOM                                              8289601 view recompilation
                                         PILE

15-MAR-12 11.58.35.353769 AM             UPGRADE    SERVER     10.2.0.5.0                                Upgraded from 10.2.0.4.0
15-MAR-12 12.03.19.478931 PM             APPLY      SERVER     10.2.0.5                                6 PSU 10.2.0.5.6                 PSU
22-MAY-12 02.44.37.950558 PM             APPLY      SERVER     10.2.0.5                                7 PSU 10.2.0.5.7                 PSU
13-SEP-12 12.14.35.820119 PM             VIEW INVAL                                              8289601 view invalidation
                                         IDATE

13-SEP-12 12.14.35.985058 PM             UPGRADE    SERVER     11.2.0.3.0                                Upgraded from 10.2.0.5.0
13-SEP-12 04.23.57.035944 PM             APPLY      SERVER     11.2.0.3                                1 PSU 11.2.0.3.1                 PSU
13-SEP-12 04.38.02.545544 PM             APPLY      SERVER     11.2.0.3                                1 PSU 11.2.0.3.1                 PSU


COL comments    FOR A70
COL action_time FOR A30
COL action      FOR A12
COL version     FOR A30

-- Historical pre 12c info
SELECT comments, version, action, TO_CHAR(action_time, 'DD-MON-YYYY HH24:MI:SS') AS action_time
FROM   sys.registry$history
WHERE  comments like '%PSU%'
AND    action = 'APPLY'
UNION ALL 
-- 12c registry for sqlpatch
SELECT description, version, action, TO_CHAR(action_time, 'DD-MON-YYYY HH24:MI:SS') AS action_time
FROM   sys.dba_registry_sqlpatch
WHERE  description like 'Database PSU%'
AND    action = 'APPLY';

COMMENTS                                                               VERSION                        ACTION       ACTION_TIME
---------------------------------------------------------------------- ------------------------------ ------------ --------------------
PSU 11.2.0.4.6                                                         11.2.0.4                       APPLY        17-SEP-2015 12:44:28
PSU 11.2.0.4.8                                                         11.2.0.4                       APPLY        13-NOV-2015 18:59:25
OJVM PSU post-install                                                  11.2.0.4.5OJVMBP               APPLY        14-NOV-2015 02:36:28
Database PSU 12.1.0.2.160419, Oracle JavaVM Component (Apr2016)        12.1.0.2                       APPLY        27-MAR-2017 09:58:19
Database PSU 12.1.0.2.170418, Oracle JavaVM Component (APR2017)        12.1.0.2                       APPLY        04-JUL-2017 21:55:04





===================
Patch details - 2
===================
Fire below command as oracle user

./opatch lsinventory

[LNDBIAU1]oracle@dbdidbu3 $ $ORACLE_HOME/OPatch/opatch lsinventory



#############################################
To know PACKAGE BODY
############################################

Select text from all_source where owner = '&OWNER' and type = '&OBJECT_type' and name = '&OBJECT_NAME';

SELECT DBMS_METADATA.GET_DDL('PACKAGE','PK_SOMENAME') FROM dual;

SELECT owner, object_name, object_type, dbms_metadata.get_ddl(replace(OBJECT_TYPE, ' ', '_'), OBJECT_NAME,OWNER)
  FROM DBA_OBJECTS
 WHERE OBJECT_TYPE = 'MATERIALIZED VIEW';


====================================
Users and their PRIVILAGES
====================================


set head off
set pages 0
set long 9999999
spool user_script.sql
SELECT DBMS_METADATA.GET_DDL('USER', USERNAME) || '/' DDL
FROM DBA_USERS
UNION ALL
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT', USERNAME) || '/' DDL
FROM DBA_USERS
UNION ALL
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT', USERNAME) || '/' DDL
FROM DBA_USERS
UNION ALL
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT', USERNAME) || '/' DDL
FROM DBA_USERS;
spool off;

wHAT PROFILE IS ASSIGNED TO USER
=============================

SELECT profile
  FROM dba_users
 WHERE username = 'KENNAM'

Then you'll want to look at the PASSWORD_LIFE_TIME and PASSWORD_GRACE_TIME parameters in the DBA_PROFILES table for the profile name identified above.


To find out MATERIALIZED VIEWS UNDER ONE SCHEMA AND THEIR LAST REFRESH TIME
==================================================================

select OWNER,OBJECT_NAME,OBJECT_TYPE from dba_objects where OBJECT_TYPE='MATERIALIZED VIEW';

select owner,NAME,LAST_REFRESH from ALL_MVIEW_REFRESH_TIMES where owner='ACCOUNTINFO';

exec dbms_mview.refresh('TDS_GRPVIEW_ACCPDT_NLD','C');

execute dbms_mview.refresh('"CORP"."NM_SV_RANGE"','C'); ==> With ownername

execute dbms_mview.refresh('"CORP"."NM_SV_RANGE"','F'); ==> FAST refresh



select 'exec dbms_mview.refresh('''||OBJECT_NAME||''',''C'');' from user_objects where OBJECT_TYPE='MATERIALIZED VIEW'; ==> Not quotation marks. Inverted comma's twice used.

DDL of MATERIALIZED VIEWS
======================

select dbms_metadata.get_ddl('MATERIALIZED_VIEW','CDS_BANK_BRANCH_NLD','ACCOUNTINFO') from dual;


DDL of all tablespaces in a database
====================================== 
select dbms_metadata.get_ddl('TABLESPACE',tablespace_name) from dba_tablespaces;


Privileges assigned to a role
======================

select * from dba_sys_privs where grantee='DBA'
/* here DBA is role name */

select privilege from role_sys_privs where role in ('CONNECT', 'RESOURCE');

select * from session_roles;

privileges and roles assigned to user
===========================

Select a.grantee User_name, a.granted_role role, b.privilege from DBA_ROLE_PRIVS a, DBA_SYS_PRIVS b where a.granted_role=b.grantee and a.grantee='DESDBA';

Rebuilding Index, which having subpartitions
==================================
select 'ALTER INDEX '||index_name|| ' REBUILD SUBPARTITION '||subpartition_name || ';' from user_ind_subpartitions where index_name='AI_ODS_TXN_IX_RPT3';





AWR report SNAP INTERVAL and RETENTION
==================================

SQL> select SNAP_INTERVAL,RETENTION from DBA_HIST_WR_CONTROL;

SNAP_INTERVAL                                                               RETENTION
--------------------------------------------------------------------------- ---------------------------------------------------------------------------
+00000 01:00:00.0                                                           +00007 00:00:00.0

Every one hour                                                                    One week (7 days)


EXECUTE dbms_workload_repository.create_snapshot(); ==> Manual creation of snap



Create table structrure from another table without data
============================================
create table temp_rel_info as select delta_version from rel_info where 1=2;

Restricted SESSION DISABLE
=======================

alter system disable restricted session; (As sys DBA)


QUERY TO DROP OBJECTS
======================

spool OBJECT_DROP_CDR1DEQ2.sql

select 'DROP '||OBJECT_TYPE||' '||OBJECT_NAME||';' from USER_OBJECTS where OBJECT_TYPE not in ('DATABASE LINK','JAVA CLASS','JAVA RESOURCE','TYPE') order by 1;

spool off;

purge recyclebin;

How to findout Parent and Child table of tables
===================================

This query gives list of children tables of a given table.
-----------------------------------------------------
SELECT p.table_name PARENT_TABLE, c.table_name CHILD_TABLE
FROM user_constraints p, user_constraints c
WHERE (p.constraint_type = 'P' OR p.constraint_type = 'U')
AND c.constraint_type = 'R'
AND p.constraint_name = c.r_constraint_name
AND p.table_name = UPPER('&tab');
 
And this one gives list of parent tables of a given table.
---------------------------------------------------------
SELECT c.table_name CHILD_TABLE, p.table_name PARENT_TABLE
FROM user_constraints p, user_constraints c
WHERE (p.constraint_type = 'P' OR p.constraint_type = 'U')
AND c.constraint_type = 'R'
AND p.constraint_name = c.r_constraint_name
AND c.table_name = UPPER('&tab');


============================================

To check tables that need REORG
========================== 

https://blog.yannickjaquier.com/oracle/table-fragmentation-identification.html
https://orahow.com/how-to-find-and-remove-table-fragmentation-in-oracle-database/ 
http://select-star-from.blogspot.com/2013/09/how-to-check-table-fragmentation-in.html
https://dbaclass.com/article/how-to-find-fragmentation-in-oracle-table/

==============================
TOP 10 defragmented tables (Good one)   http://facedba.blogspot.com/2017/04/fix-ora-10631-shrink-clause-should-not.html
============================
col table_name for a30
col owner for a30
select *
  from (select owner,table_name,
               round(((blocks * 8)/1024/1024), 1) "size (GB)",
               round((num_rows * avg_row_len / 1024/1024/1024), 1) "actual_data (GB)",
               (round(((blocks * 8)/1024/1024), 1) -
               round((num_rows * avg_row_len / 1024/1024/1024), 1)) "wasted_space (GB)"
          from dba_tables where owner='BPCLNLP' and (round((blocks * 8), 1) > round((num_rows * avg_row_len / 1024/1024/1024), 1))
         order by 4 desc)
 WHERE ROWNUM <= 10;




select
a.owner,
a.segment_name,
a.segment_type,
round(a.bytes/1024/1024,0) MBS,
round((a.bytes-(b.num_rows*b.avg_row_len) )/1024/1024,0) WASTED
from dba_segments a, dba_tables b
where a.owner=b.owner
and a.owner not like 'SYS%'
and a.segment_name = b.table_name
and a.segment_type='TABLE'
group by a.owner, a.segment_name, a.segment_type, round(a.bytes/1024/1024,0) ,round((a.bytes-(b.num_rows*b.avg_row_len) )/1024/1024,0)
having round(bytes/1024/1024,0) >100
order by round(bytes/1024/1024,0) desc ; 

dba-oracle script for reorg
=============================
set lines 200 pages 900
col owner for a20
col table_name for a30;

select 
   owner,table_name,round((blocks*8),2) "size(kb)" , 
   round((num_rows*avg_row_len/1024),2) "actual_data(kb)",
   (round((blocks*8),2) - round((num_rows*avg_row_len/1024),2)) "wasted_space(kb)"
from 
   dba_tables
where owner='&owner' and (round((blocks*8),2) > round((num_rows*avg_row_len/1024),2))
order by 5 desc;




Stats gathering at table level
======================

EXEC DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=>USER,TABNAME=>'T2',CASCADE=>TRUE,ESTIMATE_PERCENT=>100,METHOD_OPT=>'FOR ALL HIDDEN COLUMNS SIZE 254 FOR ALL INDEXED COLUMNS SIZE 254',NO_INVALIDATE=>FALSE);


Query to check Failed login attempts
=============================
COL OS_USERNAME FOR A20;
COL USERNAME FOR A20;
COL TERMINAL FOR a20;
col ACTION_NAME for a20;
col TIMESTAMP for a20;
col USERHOST for a25;

SELECT
  TO_CHAR(TIMESTAMP,'MM/DD HH24:MI') TIMESTAMP,
  SUBSTR(OS_USERNAME,1,20) OS_USERNAME,
  SUBSTR(USERNAME,1,20) USERNAME,
  SUBSTR(TERMINAL,1,20) TERMINAL,
  ACTION_NAME,USERHOST,
  RETURNCODE
FROM
  SYS.DBA_AUDIT_SESSION
WHERE
  USERNAME LIKE 'HS3'
  AND TIMESTAMP BETWEEN SYSDATE-4 AND SYSDATE
ORDER BY
  TIMESTAMP DESC;

TIMESTAMP   OS_USERNAME          USERNAME TERMINAL        ACTION_NAME          RETURNCODE
----------- -------------------- -------- --------------- -------------------- ----------
04/03 11:33 USER1                MYUSER   CUSER1          LOGON                         0
04/03 11:33 USER1                MYUSER   CUSER1          LOGOFF                        0
04/03 11:33 USER1                MYUSER   CUSER1          LOGOFF                        0
04/02 19:11 USER1                MYUSER   CUSER1-LT       LOGON                     28000
04/02 18:37 USER1                MYUSER   CUSER1-LT       LOGON                     28000
04/02 18:37 USER1                MYUSER   CUSER1-LT       LOGON                     28000
04/02 18:37 USER1                MYUSER   CUSER1-LT       LOGON                      1017
04/02 18:37 USER1                MYUSER   CUSER1-LT       LOGON                     28000
04/02 18:32 USER1                MYUSER   CUSER1-LT       LOGON                      1017
04/02 18:32 USER1                MYUSER   CUSER1-LT       LOGON                      1017
04/02 18:31 USER1                MYUSER   CUSER1-LT       LOGON                      1017
04/02 18:31 USER1                MYUSER   CUSER1-LT       LOGON                      1017

RETURNCODE=0 indicates success
RETURNCODE=1017 indicates bad password
RETURNCODE=28000 indicates account is locked out


PASWORD EXPIRY REPORT
================
select username,account_status, expiry_date, trunc(expiry_date-sysdate) from dba_users order by 1;

To find out Auto Extendible Option
==========================

select tablespace_name, file_name, bytes/1048576 File_Size_MB, autoextensible, increment_by from dba_data_files order by file_id;

Matview refresh script
=================
select 'exec dbms_mview.refresh('''||OBJECT_NAME||''',''C'');' FROM USER_OBJECTS WHERE OBJECT_TYPE='MATERIALIZED VIEW';



To identify all locked sessions in an Oracle database:
=======================================

Query 1:
=========

SELECT oracle_username || ' (' || s.osuser || ')' username,
         s.sid || ',' || s.serial# sess_id,
         owner || '.' || object_name object,
         object_type,
         DECODE (l.block, 0, 'Not Blocking', 1, 'Blocking', 2, 'Global') STATUS,
         DECODE (v.locked_mode,
                 0, 'None',
                 1, 'Null',
                 2, 'Row-S (SS)',
                 3, 'Row-X (SX)',
                 4, 'Share',
                 5, 'S/Row-X (SSX)',
                 6, 'Exclusive',
                 TO_CHAR (lmode))
            mode_held
    FROM v$locked_object v,
         dba_objects d,
         v$lock l,
         v$session s
   WHERE     v.object_id = d.object_id
         AND v.object_id = l.id1
         AND v.session_id = s.sid
ORDER BY oracle_username, session_id;

Query 2:
========
SELECT c.owner,  c.object_name,  c.object_type,  b.sid,  b.serial#,  b.STATUS,  b.osuser,  
b.machine FROM v$locked_object a ,  v$session b,  dba_objects c WHERE b.sid     = a.session_id AND a.object_id = c.object_id;
 
Output example:
=============
OWNER	 OBJECT_NAME	SID,SERIAL OBJECT      OBJECT_TYPE   STATUS	     MODE_HELD
SCHEMA_1 (user.test)	738,9076   SCHEMA1.EMP TABLE	     NOT    Blocking Share



Stats Gathering at table level
================================
1. To gather table statistics with DBMS_STATS
 
SQL> EXECUTE DBMS_STATS.GATHER_TABLE_STATS(ownname => 'HR', tabname => 'EMP')

SQL> EXEC DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=>USER,TABNAME=>'T2',CASCADE=>TRUE,ESTIMATE_PERCENT=>100,METHOD_OPT=>'FOR ALL HIDDEN COLUMNS SIZE 254 FOR ALL INDEXED COLUMNS SIZE 254',NO_INVALIDATE=>FALSE);

scott@9i > exec dbms_stats.gather_table_stats('SCOTT','ANOTHER_EMP',ESTIMATE_PERCENT=>100,METHOD_OPT=>'for all indexed columns size auto',CASCADE=>True);

PL/SQL procedure successfully completed

scott@9i > select table_name,column_name,num_distinct,last_analyzed,num_buckets from user_tab_cols where table_name like ('%EMP%');

TABLE_NAME                     COLUMN_NAME                    NUM_DISTINCT LAST_ANAL NUM_BUCKETS
------------------------------ ------------------------------ ------------ --------- -----------
ANOTHER_EMP                    EMPNO                                    14 04-APR-06           1
ANOTHER_EMP                    ENAME
ANOTHER_EMP                    JOB                                       5 04-APR-06           1




What user is waiting the most?
========================
 select 	sesion.sid,
           	sesion.username,
            	sum(active_session_history.wait_time +
               active_session_history.time_waited) ttl_wait_time
      from v$active_session_history active_session_history,v$session sesion
      where active_session_history.sample_time between sysdate - 60/2880 and sysdate
       and active_session_history.session_id = sesion.sid
    group by sesion.sid, sesion.username
   order by 3

What object is currently causing the highest resource waits?
==============================================
select dba_objects.object_name,
            dba_objects.object_type,
            active_session_history.event,
            sum(active_session_history.wait_time +
                active_session_history.time_waited) ttl_wait_time
       from v$active_session_history active_session_history,
            dba_objects
      where active_session_history.sample_time between sysdate - 60/2880 and sysdate
        and active_session_history.current_obj# = dba_objects.object_id
    group by dba_objects.object_name, dba_objects.object_type, active_session_history.event
   order by 4

What resource is currently in high demand?
=================================
select active_session_history.event,
           sum(active_session_history.wait_time +
                active_session_history.time_waited) ttl_wait_time
       from v$active_session_history active_session_history
      where active_session_history.sample_time between sysdate - 60/2880 and sysdate
    group by active_session_history.event
    order by 2

Index rebuilding
============

SELECT 'ALTER index '||index_name||' rebuild nologging;' from  dba_indexes where owner='RMAUSER' and status='UNUSABLE';

Invalid Objects
===========
 SELECT 'ALTER '||OBJECT_TYPE||' '||OBJECT_NAME||' compile;' from  dba_objects where owner='RMAUSER' and status='INVALID';

REORG
======

SQL> alter table LSI_QUEUES move;

Table altered.

SQL> alter table LSI_QUEUES move lob (QUE_DATA1) STORE AS (TABLESPACE RMAUSER);

Table altered.

SQL> alter table LSI_QUEUES move lob (QUE_DATA2) STORE AS (TABLESPACE RMAUSER);

Table altered.

SQL> alter table LSI_QUEUES move lob (QUE_DATA3) STORE AS (TABLESPACE RMAUSER);

Table altered.

SQL> alter index IDX_LSI_QUEUES_Q rebuild nologging;

Index altered.


Top wait events
====================

set linesize 100
col TIME_WAITED_MICRO format 99999999999999
col EVENT format a40
select * from (select event, TIME_WAITED_MICRO from v$SYSTEM_EVENT
where
        event not like '%timer%'
        and event not like '%heartbeat%'
        and event not like '%SQL%'
        and event not like 'pipe get'
        and event not like 'rdbms ipc message'
order by TIME_WAITED_MICRO desc) where rownum < 11;


Top 10 tables causing buffer busy waits
=======================================

set linesize 100
col object_name format a40
col value format 9999999999
col STATISTIC_NAME format a19
select OWNER,OBJECT_NAME,STATISTIC_NAME,VALUE from
(select * from v$segment_statistics where statistic_name = 'buffer busy waits' order by VALUE desc)
 where rownum < 11 and owner noT IN ('SYS') order by 4 desc;

prompt Top 10 tables with row lock waits
================================

prompt
set linesize 100
col object_name format a40
col value format 9999999999
col STATISTIC_NAME format a15
select OWNER,OBJECT_NAME,STATISTIC_NAME,VALUE from
(select * from v$segment_statistics where statistic_name = 'row lock waits' order by VALUE desc) where rownum < 11 and owner
 not in ('SYS') order by 4 desc;

Undo and Temp space usage
============================

column dummy noprint
set linesize 100
column  pct_used format 999.9       heading "%|Used"
column  name    format a36      heading "Undo Name"
column  Kbytes   format 999,999,999    heading "KBytes"
column  used    format 999,999,999   heading "Used"
column  free    format 999,999,999  heading "Free"
column  largest    format 999,999,999  heading "Largest"
column  max_size format 999,999,999 heading "MaxPoss|Kbytes"
column  pct_max_used format 999.9       heading "%|Max|Used"
break   on report
compute sum of kbytes on report
compute sum of free on report
compute sum of used on report

select nvl(b.tablespace_name,
             nvl(a.tablespace_name,'UNKOWN')) name,
       kbytes_alloc kbytes,
       kbytes_alloc-nvl(kbytes_free,0) used,
       nvl(kbytes_free,0) free,
       ((kbytes_alloc-nvl(kbytes_free,0))/
                          kbytes_alloc)*100 pct_used,
       nvl(largest,0) largest
from ( select sum(bytes)/1024 Kbytes_free,
              max(bytes)/1024 largest,
              tablespace_name
       from  sys.dba_free_space
       group by tablespace_name ) a,
     ( select sum(bytes)/1024 Kbytes_alloc,
              tablespace_name
       from sys.dba_data_files
       group by tablespace_name )b
where a.tablespace_name (+) = b.tablespace_name
AND (A.TABLESPACE_NAME like '%UNDO%' or A.TABLESPACE_NAME LIKE '%TEMP%');



Actions taken on Database. Details updated in DATABASE REGISTRY
====================================================
select ACTION_TIME,COMMENTS from DBA_REGISTRY_HISTORY;

select * from registry$history;

To findout whether server is dedicatd or shared
====================================

select username, server, count(*) from v$session where username is not null group by username, server; 

To check objects assigned to perticualar user on a perticualr tablespace
=======================================================

select count(*),SEGMENT_TYPE,TABLESPACE_NAME from dba_segments where OWNER='$OWNER' group by SEGMENT_TYPE,TABLESPACE_NAME;

v$resource_limit to check sessions and process count
============================================

desc v$resource_limit;

Password BACKUP 
==============

SQL> select PASSWORD from sys.user$ where NAME='DESDBA';

PASSWORD
------------------------------
62CC2E4DB41F2176

alter user DBAI_REP identified by values '62CC2E4DB41F2176';

select 'alter user "'||username||'" identified by values '''||extract(xmltype(dbms_metadata.get_xml('USER',username)),'//USER_T/PASSWORD/text()').getStringVal()||''';'  statement from dba_users;

Output
=======

alter user "PRIS_OWNER" identified by values 'C67A520120841439';
alter user "AUDTASK" identified by values 'PASSWORD UNKNOWN';
alter user "AUD_OWNER" identified by values 'ACCOUNT DISABLED';
alter user "STP1DEP1" identified by values 'B3CC311D441D934D';
alter user "DBA_MON" identified by values '47099BC1E38AF387';
alter user "DB4SIGHT" identified by values '53FC039FAFD3AC63';
alter user "ADDM" identified by values '10BDB886BD804740';
alter user "GGATE_USER" identified by values 'B0ACB617B015CC9E';
alter user "PRIS_USER" identified by values '9962782CBA966015';
alter user "GGATE" identified by values '5E8E760A64854175';
alter user "GES_OWNER" identified by values '2DA739B729EDC237';
alter user "FSF_READ" identified by values '0EA5FF54CB6D929E';
alter user "FSF_READ1" identified by values 'AA6B8D676FFCDF11';
alter user "FSF_OWNER1" identified by values '3C07B2145C2A2F2B';
alter user "FSF_USER1" identified by values '36A462BB003C16D9';



check filesystem space
=================
du -sh * sort -n

if above command not works

du -sg * | sort -n

du -k * 
du -m *
du -g *

du -k | sort -n

du -sm * | sort -nr | head -2

$ du -sm TISP001A_expdp.dmp
262637.05       TISP001A_expdp.dmp

$ du -sg TISP001A_expdp.dmp
256.48  TISP001A_expdp.dmp



Tables last analysed
===============

SELECT table_name, to_char(last_analyzed, 'yyyy/mm/dd hh:mi:ss') LAST_ANALYSED FROM   user_tables;

OPEN Cursors
===========
col USER_NAME for a15;
select USER_NAME, sql_text, count(*) from v$open_cursor where USER_NAME not in ('SYS','SYSTEM','DESDBA') group by USER_NAME,sql_text order by count(*) desc;

SQL>  select max(a.value) as highest_open_cur, p.value as max_open_cur from v$sesstat a, v$statname b, v$parameter p where a.statistic# = b.statistic# and b.name = 'opened cursors current'  and p.name= 'open_cursors' group by p.value;

HIGHEST_OPEN_CUR  MAX_OPEN_CUR
----------------       ----------------------------------------
              29            1000

SQL> select *  from (  select ss.value, sn.name, ss.sid  from v$sesstat ss,  v$statname sn  where ss.statistic# = sn.statistic#  and sn.name like '%opened cursors current%' order by value desc)  where rownum < 11 ;

     VALUE NAME                                                                    SID
---------- ---------------------------------------------------------------- ----------
        29 opened cursors current                                                  546
        22 opened cursors current                                                  537
        18 opened cursors current                                                  500
        17 opened cursors current                                                  499
        13 opened cursors current                                                  449
        13 opened cursors current                                                  423
        13 opened cursors current                                                  394
        12 opened cursors current                                                  487
        11 opened cursors current                                                  494
        11 opened cursors current                                                  441


Script to Compile all invalid Materialized Views in a schema
============================================
select 'alter '||object_type||' '||owner||'."'||object_name||'" compile;' from dba_objects where owner = 'OWNER' and object_type = 'MATERIALIZED VIEW' and status <> 'VALID'

Script to show redolog file info and log switches (redolog file growth)
https://www.thegeekdiary.com/script-to-find-redolog-switch-history-and-find-archivelog-size-for-each-instances-in-oracle-rac/
=============================================

/* setting up the environment */
set linesize 200 pagesize 1000
column day format a3
column total format 9999
column h00 format 999
column h01 format 999
column h02 format 999
column h03 format 999
column h04 format 999
column h04 format 999
column h05 format 999
column h06 format 999
column h07 format 999
column h08 format 999
column h09 format 999
column h10 format 999
column h11 format 999
column h12 format 999
column h13 format 999
column h14 format 999
column h15 format 999
column h16 format 999
column h17 format 999
column h18 format 999
column h19 format 999
column h20 format 999
column h21 format 999
column h22 format 999
column h23 format 999
column h24 format 999
break on report
compute max of "total" on report
compute max of "h01" on report
compute max of "h02" on report
compute max of "h03" on report
compute max of "h04" on report
compute max of "h05" on report
compute max of "h06" on report
compute max of "h07" on report
compute max of "h08" on report
compute max of "h09" on report
compute max of "h10" on report
compute max of "h11" on report
compute max of "h12" on report
compute max of "h13" on report
compute max of "h14" on report
compute max of "h15" on report
compute max of "h16" on report
compute max of "h17" on report
compute max of "h18" on report
compute max of "h19" on report
compute max of "h20" on report
compute max of "h21" on report
compute max of "h22" on report
compute max of "h23" on report
compute sum of NUM on report
compute sum of GB on report
compute sum of MB on report
compute sum of KB on report

/* Report the Redo Log Switch History */

alter session set nls_date_format='DD MON YYYY';
select thread#, trunc(completion_time) as "date", to_char(completion_time,'Dy') as "Day", count(1) as "total",
sum(decode(to_char(completion_time,'HH24'),'00',1,0)) as "h00",
sum(decode(to_char(completion_time,'HH24'),'01',1,0)) as "h01",
sum(decode(to_char(completion_time,'HH24'),'02',1,0)) as "h02",
sum(decode(to_char(completion_time,'HH24'),'03',1,0)) as "h03",
sum(decode(to_char(completion_time,'HH24'),'04',1,0)) as "h04",
sum(decode(to_char(completion_time,'HH24'),'05',1,0)) as "h05",
sum(decode(to_char(completion_time,'HH24'),'06',1,0)) as "h06",
sum(decode(to_char(completion_time,'HH24'),'07',1,0)) as "h07",
sum(decode(to_char(completion_time,'HH24'),'08',1,0)) as "h08",
sum(decode(to_char(completion_time,'HH24'),'09',1,0)) as "h09",
sum(decode(to_char(completion_time,'HH24'),'10',1,0)) as "h10",
sum(decode(to_char(completion_time,'HH24'),'11',1,0)) as "h11",
sum(decode(to_char(completion_time,'HH24'),'12',1,0)) as "h12",
sum(decode(to_char(completion_time,'HH24'),'13',1,0)) as "h13",
sum(decode(to_char(completion_time,'HH24'),'14',1,0)) as "h14",
sum(decode(to_char(completion_time,'HH24'),'15',1,0)) as "h15",
sum(decode(to_char(completion_time,'HH24'),'16',1,0)) as "h16",
sum(decode(to_char(completion_time,'HH24'),'17',1,0)) as "h17",
sum(decode(to_char(completion_time,'HH24'),'18',1,0)) as "h18",
sum(decode(to_char(completion_time,'HH24'),'19',1,0)) as "h19",
sum(decode(to_char(completion_time,'HH24'),'20',1,0)) as "h20",
sum(decode(to_char(completion_time,'HH24'),'21',1,0)) as "h21",
sum(decode(to_char(completion_time,'HH24'),'22',1,0)) as "h22",
sum(decode(to_char(completion_time,'HH24'),'23',1,0)) as "h23"
from
v$archived_log
where first_time > trunc(sysdate-10)
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
group by thread#, trunc(completion_time), to_char(completion_time, 'Dy') order by 2,1;



/* calculate the archive log size generated per day for each Instances. */

select THREAD#, trunc(completion_time) as "DATE"
, count(1) num
, trunc(sum(blocks*block_size)/1024/1024/1024) as GB
, trunc(sum(blocks*block_size)/1024/1024) as MB
, sum(blocks*block_size)/1024 as KB
from v$archived_log
where first_time > trunc(sysdate-10) 
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
group by thread#, trunc(completion_time)
order by 2,1
;



Ttitle off
prompt =========================================================================================================================         


TO FINDOUT TABLES SIZE IN A SCHEMA
===============================

COLUMN OWNER FORMAT A30
COLUMN TABLE FORMAT A30
COLUMN Taille FORMAT A15
COLUMN TABLESPACE FORMAT A20

SELECT "OWNER","TABLE","DB Blocks",ROUND(DECODE(SIGN("Size"/1048576 -1 ) , -1 , DECODE(SIGN("Size"/1024 -1), -1, "Size",  "Size"/1024), "Size"/1048576) ,2) "SIZE", DECODE(SIGN("Size"/1048576 -1 ) , -1, DECODE(SIGN("Size"/1024 -1)  ,-1 ,' Byte'  , ' Kb') , ' Mb') " ",      "TABLESPACE" FROM (SELECT owner "OWNER" , segment_name "TABLE"  , SUM(BYTES)   "Size" , blocks "DB Blocks" , tablespace_name "TABLESPACE" FROM DBA_SEGMENTS WHERE segment_type = 'TABLE'  AND DECODE('&&ownr', null,'X', OWNER) = DECODE('&&ownr',null,'X',UPPER('&&ownr'))  AND OWNER NOT IN ('SYS' , 'SYSTEM') GROUP BY owner, segment_name, tablespace_name, blocks ORDER BY owner, segment_name) ;  

=================================================================================================================================

**************************************
To find out complete performance of a database
**************************************

set serveroutput on
declare 
cursor c1 is select version
from v$instance;
cursor c2 is
    select
          host_name
       ,  instance_name
       ,  to_char(sysdate, 'HH24:MI:SS DD-MON-YY') currtime
       ,  to_char(startup_time, 'HH24:MI:SS DD-MON-YY') starttime
     from v$instance;
cursor c4 is
select * from (SELECT count(*) cnt, substr(event,1,50) event
FROM v$session_wait
WHERE wait_time = 0
AND event NOT IN ('smon timer','pipe get','wakeup time manager','pmon timer','rdbms ipc message',
'SQL*Net message from client')
GROUP BY event
ORDER BY 1 DESC) where rownum <6;
cursor c5 is
select round(sum(value)/1048576) as sgasize from v$sga;
cursor c6 is select round(sum(bytes)/1048576) as dbsize
from v$datafile;
cursor c7 is select 'top physical i/o process' category, sid,
       username, total_user_io amt_used,
       round(100 * total_user_io/total_io,2) pct_used
from (select b.sid sid, nvl(b.username, p.name) username,
             sum(value) total_user_io
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
      and b.sid = a.sid
      and c.name in ('physical reads', 'physical writes',
                     'physical reads direct',
                     'physical reads direct (lob)',
                     'physical writes direct',
                     'physical writes direct (lob)')
      and b.username not in ('SYS', 'SYSTEM', 'SYSMAN', 'DBSNMP')
      group by b.sid, nvl(b.username, p.name)
      order by 3 desc),
     (select sum(value) total_io
      from v$statname c, v$sesstat a
      where a.statistic# = c.statistic#
      and c.name in ('physical reads', 'physical writes',
                       'physical reads direct',
                       'physical reads direct (lob)',
                       'physical writes direct',
                       'physical writes direct (lob)'))
where rownum < 2
union all
select 'top logical i/o process', sid, username,
       total_user_io amt_used,
       round(100 * total_user_io/total_io,2) pct_used
from (select b.sid sid, nvl(b.username, p.name) username,
             sum(value) total_user_io
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
      and b.sid = a.sid
      and c.name in ('consistent gets', 'db block gets')
      and b.username not in ('SYS', 'SYSTEM', 'SYSMAN', 'DBSNMP')
      group by b.sid, nvl(b.username, p.name)
      order by 3 desc),
     (select sum(value) total_io
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
 and b.sid = a.sid
      and c.name in ('consistent gets', 'db block gets'))
where rownum < 2
union all
select 'top memory process', sid,
       username, total_user_mem,
       round(100 * total_user_mem/total_mem,2)
from (select b.sid sid, nvl(b.username, p.name) username,
             sum(value) total_user_mem
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
      and b.sid = a.sid
      and c.name in ('session pga memory', 'session uga memory')
      and b.username not in ('SYS', 'SYSTEM', 'SYSMAN', 'DBSNMP')
      group by b.sid, nvl(b.username, p.name)
      order by 3 desc),
     (select sum(value) total_mem
      from v$statname c, v$sesstat a
      where a.statistic# = c.statistic#
      and c.name in ('session pga memory', 'session uga memory'))
where rownum < 2
union all
select 'top cpu process', sid, username,
       total_user_cpu,
       round(100 * total_user_cpu/greatest(total_cpu,1),2)
from (select b.sid sid, nvl(b.username, p.name) username,
             sum(value) total_user_cpu
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
      and b.sid = a.sid
      and c.name = 'CPU used by this session'
      and b.username not in ('SYS', 'SYSTEM', 'SYSMAN', 'DBSNMP')
      group by b.sid, nvl(b.username, p.name)
      order by 3 desc),
     (select sum(value) total_cpu
      from v$statname c, v$sesstat a,
           v$session b, v$bgprocess p
      where a.statistic# = c.statistic#
      and p.paddr (+) = b.paddr
      and b.sid = a.sid
      and c.name = 'CPU used by this session')
where rownum < 2;
cursor c8 is select username, sum(VALUE/100) cpu_usage_sec
from v$session ss, v$sesstat se, v$statname sn
where se.statistic# = sn.statistic#
and name like '%CPU used by this session%'
and se.sid = ss.sid
and username is not null
and username not in ('SYS', 'SYSTEM', 'SYSMAN', 'DBSNMP')
group by username
order by 2 desc;
begin
dbms_output.put_line ('Database Version');
dbms_output.put_line ('-----------------');
for rec in c1
loop
dbms_output.put_line(rec.version);
end loop;
dbms_output.put_line( chr(13) );
dbms_output.put_line('Hostname');
dbms_output.put_line ('----------');
for rec in c2
loop
     dbms_output.put_line(rec.host_name);
end loop;
dbms_output.put_line( chr(13) );
dbms_output.put_line('SGA Size (MB)');
dbms_output.put_line ('-------------');
for rec in c5
loop
     dbms_output.put_line(rec.sgasize);
end loop;
dbms_output.put_line( chr(13) );
dbms_output.put_line('Database Size (MB)');
dbms_output.put_line ('-----------------');
for rec in c6
loop
     dbms_output.put_line(rec.dbsize);
end loop;
dbms_output.put_line( chr(13) );
dbms_output.put_line('Instance start-up time');
dbms_output.put_line ('-----------------------');
for rec in c2 loop
 dbms_output.put_line( rec.starttime );
  end loop;
dbms_output.put_line( chr(13) );
  for b in
    (select total, active, inactive, system, killed
    from
       (select count(*) total from v$session)
     , (select count(*) system from v$session where username is null)
     , (select count(*) active from v$session where status = 'ACTIVE' and username is not null)


     , (select count(*) inactive from v$session where status = 'INACTIVE')
     , (select count(*) killed from v$session where status = 'KILLED')) loop
dbms_output.put_line('Active Sessions');
dbms_output.put_line ('---------------');
dbms_output.put_line(b.total || ' sessions: ' || b.inactive || ' inactive,' || b.active || ' active, ' || b.system || ' system, ' || b.killed || ' killed ');
  end loop;
  dbms_output.put_line( chr(13) );
 dbms_output.put_line( 'Sessions Waiting' );
  dbms_output.put_line( chr(13) );
dbms_output.put_line('Count      Event Name');
dbms_output.put_line('-----      -----------------------------------------------------');
for rec in c4 
loop
dbms_output.put_line(rec.cnt||'          '||rec.event);
end loop;
dbms_output.put_line( chr(13) );


dbms_output.put_line('-----      -----------------------------------------------------');


dbms_output.put_line('TOP Physical i/o, logical i/o, memory and CPU processes');
dbms_output.put_line ('---------------');
for rec in c7
loop
dbms_output.put_line (rec.category||': SID '||rec.sid||' User : '||rec.username||': Amount used : '||rec.amt_used||': Percent used: '||rec.pct_used);
end loop;


dbms_output.put_line('------------------------------------------------------------------');


dbms_output.put_line('TOP CPU users by usage');
dbms_output.put_line ('---------------');
for rec in c8
loop


dbms_output.put_line (rec.username||'--'||rec.cpu_usage_sec);
dbms_output.put_line ('---------------');
end loop;

end;
/

=====================================================================================================================================

DIAG INFO
=========

select * from v$diag_info;

  INST_ID NAME                 VALUE
---------- -------------------- --------------------------------------------------------------------------------
         1 Diag Enabled         TRUE
         1 ADR Base             /data/oracle/LNGBCFU3/admin/diag
         1 ADR Home             /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3
         1 Diag Trace           /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/trace
         1 Diag Alert           /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/alert
         1 Diag Incident        /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/incident
         1 Diag Cdump           /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/cdump
         1 Health Monitor       /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/hm
         1 Default Trace File   /data/oracle/LNGBCFU3/admin/diag/diag/rdbms/lngbcfu3/LNGBCFU3/trace/LNGBCFU3_ora
                                _18863.trc

         1 Active Problem Count 28
         1 Active Incident Coun 384
           t


=========================================================================================

CPU Utilisation by USER NAME
==============================

select 	ss.username,
	se.SID,
	VALUE/100 cpu_usage_seconds
from 	v$session ss, 
	v$sesstat se, 
	v$statname sn
where  	se.STATISTIC# = sn.STATISTIC#
and  	NAME like '%CPU used by this session%'
and  	se.SID = ss.SID
and ss.status='ACTIVE'
and ss.username is not null
order  	by VALUE desc 

==============================================
CPU Utilisation 2nd query with seconds in time
===============================================

COLUMN username FORMAT A30
COLUMN sid FORMAT 999,999,999
COLUMN serial# FORMAT 999,999,999
COLUMN "cpu usage (seconds)"  FORMAT 999,999,999.0000
 
SELECT
   s.username,
   t.sid,
s.status,
   s.serial#,
   SUM(VALUE/100) as "cpu usage (seconds)"
FROM
   gv$session s,
   gv$sesstat t,
   gv$statname n
WHERE
   t.STATISTIC# = n.STATISTIC#
AND
   NAME like '%CPU used by this session%'
AND
   t.SID = s.SID
AND
   s.username is not null
GROUP BY username,t.sid,s.serial#,s.status
/




To see archive destination path
=========================
select DESTINATION from v$archive_dest;


ORA-00054: resource busy and acquire with NOWAIT specified or timeout expired (To check which object is locking)
=======================================================================================

set lines 100 pages 999
col username 	format a20
col sess_id 	format a10
col object	format a25
col mode_held	format a10
select	oracle_username || ' (' || s.osuser || ')' username
,	s.sid || ',' || s.serial# sess_id
,	owner || '.' ||	object_name object
,	object_type
,	decode(	l.block
	,	0, 'Not Blocking'
	,	1, 'Blocking'
	,	2, 'Global') status
,	decode(v.locked_mode
	,	0, 'None'
	,	1, 'Null'
	,	2, 'Row-S (SS)'
	,	3, 'Row-X (SX)'
	,	4, 'Share'
	,	5, 'S/Row-X (SSX)'
	,	6, 'Exclusive', TO_CHAR(lmode)) mode_held
from	v$locked_object v
,	dba_objects d
,	v$lock l
,	v$session s
where 	v.object_id = d.object_id
and 	v.object_id = l.id1
and 	v.session_id = s.sid
order by oracle_username
,	session_id
/

=========================================================================================
Library cache locks
================================================

select sid,saddr from v$session where event= 'library cache lock';

SID SADDR
---------- --------
16 572ed244


select kgllkhdl Handle,kgllkreq Request, kglnaobj Object from x$kgllk where kgllkses = '572ed244' and kgllkreq > 0;

HANDLE   REQUEST   OBJECT
-------- ---------- ------------
62d064dc          2 EMPLOYEES

select kgllkses saddr,kgllkhdl handle,kgllkmod mod,kglnaobj object from x$kgllk lock_a where kgllkmod > 0 and exists (select lock_b.kgllkhdl from x$kgllk lock_b where kgllkses = '572ed244' /* blocked session */ and lock_a.kgllkhdl = lock_b.kgllkhdl and kgllkreq > 0);

SADDR     HANDLE   MOD
--------  -------- ----------
OBJECT
------------------------------------------------------------
572eac94  62d064dc          3
EMPLOYEES

============================================================
SQL's currently running on database
===========================================================

select S.USERNAME, s.sid, s.osuser, t.sql_id, sql_text from v$sqltext_with_newlines t,V$SESSION s 
where t.address =s.sql_address and t.hash_value = s.sql_hash_value and s.status = 'ACTIVE' and s.username <> 'SYSTEM' order by s.sid,t.piece;

History of UNCOMMITTED Transactions
=============================

select b.inst_id, b.sid, b.serial#,b.username,b.machine ,b.status,b.prev_sql_id,c.sql_text,d.object_id,e.object_name,
a.start_time,to_char(b.logon_time,’MM/DD/YY HH24:MI:SS’) logon_time
from    gv$transaction a ,
gv$session b ,
gv$sql c,
v$locked_object d,
all_objects e
where a.inst_id = b.inst_id
and a.ses_addr = b.SADDR
and b.prev_sql_addr = c.address(+)
and b.prev_hash_value = c.hash_value(+)
and b.prev_child_number = c.child_number(+)
and b.inst_id = c.inst_id(+)
and b.prev_sql_id=c.sql_id
and d.object_id=e.object_id
and d.session_id=b.sid(+);

==================
Blocking sessions history
==================

SELECT *
  FROM (  SELECT a.sql_id,
                 a.sample_time,
                 COUNT (*)
                 OVER (PARTITION BY a.blocking_session, a.user_id, a.program)
                    cpt,
                 ROW_NUMBER ()
                 OVER (PARTITION BY a.blocking_session, a.user_id, a.program
                       ORDER BY blocking_session, a.user_id, a.program)
                    rn,
                 a.blocking_session,
                 a.user_id,
                 a.program,
                 s.sql_text
            FROM sys.WRH$_ACTIVE_SESSION_HISTORY a, sys.wrh$_sqltext s
           WHERE     a.sql_id = s.sql_id
                 AND blocking_session_serial# <> 0
                 AND a.user_id <> 0
                 AND a.sample_time > SYSDATE – 1
        ORDER BY a.sample_time)
 WHERE rn = 1;

==================
Killed session information
===================

select * from v$process where addr=(select creator_addr from v$session where sid=< sid used in alter system kill session command >);

===================================
XDB installed or not
===================================

SQL> select COMP_ID,COMP_NAME,VERSION,STATUS from DBA_REGISTRY where COMP_ID='XDB';

no rows selected

SHARED POOL USAGE
====================

set pagesize 132
column owner format a16
column name  format a36
column sharable_mem format 999,999,999
column executions   format 999,999,999
prompt
prompt  Memory Usage of Shared Pool Order - Biggest First
prompt
column name format 45
select  owner, name||' - '||type name, sharable_mem from v$db_object_cache where sharable_mem > 10000 and type in ('PACKAGE', 'PACKAGE BODY', 'FUNCTION', 'PROCEDURE') order by sharable_mem desc;
/

prompt
prompt  Loads into Shared Pool  - Most Loads First
prompt
select  owner, name||' - '||type name, loads , sharable_mem from v$db_object_cache where loads > 3 and type in ('PACKAGE', 'PACKAGE BODY', 'FUNCTION', 'PROCEDURE') order by loads desc;
/

prompt
prompt  Executions of Objects in the  Shared Pool  - Most Executions First
prompt

select  owner, name||' - '||type name, executions from v$db_object_cache where executions  > 100 and type in ('PACKAGE', 'PACKAGE BODY', 'FUNCTION', 'PROCEDURE') order by executions  desc;
/

========================================================================================


2 PHASE Commit STATEMENTS
=========================

col HOST for a25;
col OS_USER for a15;
select LOCAL_TRAN_ID,STATE,FAIL_TIME,FORCE_TIME,RETRY_TIME,OS_USER,HOST from dba_2pc_pending;

LOCAL_TRAN_ID          STATE            FAIL_TIME FORCE_TIM RETRY_TIM OS_USER                        HOST
---------------------- ---------------- --------- --------- --------- ------------------------------ ------------------------------
134.27.111838          prepared         27-MAR-13           01-APR-13 sprisw2                        prisapsit2.uk.db.com
8.16.1319686           prepared         27-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
133.30.114992          prepared         27-MAR-13           01-APR-13 sprisw2                        prisapsit2.uk.db.com
15.30.1509096          prepared         27-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
109.25.272407          prepared         27-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
138.8.84115            prepared         27-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
55.33.943863           prepared         27-MAR-13           01-APR-13 sprisw2                        prisapsit2.uk.db.com
114.26.211738          prepared         27-MAR-13           01-APR-13 sprisw2                        prisapsit2.uk.db.com
71.16.883387           prepared         27-MAR-13           01-APR-13 sprisw2                        prisapsit2.uk.db.com
146.1.71895            prepared         27-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
43.20.1337013          prepared         31-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
91.13.1206717          prepared         31-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com
52.13.985157           prepared         31-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com =====>
435.4.157244           prepared         31-MAR-13           02-APR-13 sprisw2                        prisapsit2.uk.db.com

14 rows selected.

For force rollback give below command

SQL> execute dbms_transaction.rollback_force('52.13.985157');

PL/SQL procedure successfully completed.

(or)

ROLLBACK FORCE '52.13.985157';

==============================================
FOR SQL TUNING
===============================================

sql> @/data/oracle/product/10.2.0.3/rdbms/admin/sqltrpt.sql

(Or)

https://support.oracle.com/epmos/faces/ui/km/SearchDocDisplay.jspx?_afrLoop=1480615258470535&type=DOCUMENT&id=262687.1&displayIndex=1&_afrWindowMode=0&_adf.ctrl-state=154y7oie7w_133
 
Content
=========

Purpose
This article provides an introduction to the use of the SQL TUNING ADVISOR (STA) via the DBMS_SQLTUNE package.
Scope
DBAs and Support Analysts
Details
The SQL Tuning Advisor automates the entire SQL tuning process replacing manual SQL tuning. It analyzes candidate SQL statements, and executes a complete analysis of the statements including: 
Determining stale or missing statistics 
Determining better execution plans 
Detecting better access paths and objects required to satisfy them (indexes, materialized views) 
Restructuring SQL
While the primary interface for the SQL Tuning Advisor is the Oracle Enterprise Manager Database Control, the advisor can also be controlled with procedures in the DBMS_SQLTUNE package.  Output can be queried via the various advisory views in SQL*Plus.
To use these procedures the user must have been granted the DBA role and the ADVISOR privilege (If using the SQL Tuning Advisor in Oracle Enterprise Manager, the user must have been granted the select_catalog_role role).

Running SQL Tuning Advisor using the DBMS_SQLTUNE package is a two-step process:
1.	Create a SQL tuning task 
2.	Execute a SQL tuning task
Note: You can run SQL Tuning Advisor from the command line using $ORACLE_HOME/rdbms/admin/sqltrpt.sql
Example:
This example is based on the "SH" account executing the various tasks. To allow the "SH" user to both create task and execute it user "SH" needs to be granted proper access:
        CONNECT / AS SYSDBA
        GRANT ADVISOR TO SH;
        GRANT SELECT_CATALOG_ROLE TO SH;
        GRANT EXECUTE ON DBMS_SQLTUNE TO SH;

The example presented makes use of a table called SALES, residing in the 
SH schema. The table Is not analyzed.
Create a SQL tuning task
You can create tuning tasks from the following: 
SQL statement selected by SQL identifier from the cursor cache 
SQL Tuning Set containing multiple statements 
Text of a single SQL statement 
SQL statement selected by SQL identifier from the Automatic Workload Repository.

You can create the task using the following: 

DECLARE
  my_task_name VARCHAR2(30);
  my_sqltext CLOB;
BEGIN
  my_sqltext := 'SELECT * '   ||
                'FROM sales ' || 'WHERE prod_id = 10 AND ' || 'cust_id = 100 ';

  my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK(
                           sql_text => my_sqltext,
                           user_name => 'SH',
                           scope => 'COMPREHENSIVE',
                           time_limit => 60,
                           task_name => 'TEST_sql_tuning_task',
                           description => 'Task to tune a query on a specified PRODUCT');
END;


Parameter explanation: 
User_name: User under which the CREATE_TUNING_TASK function analyzes the SQL statement. 
Scope: COMPREHENSIVE. This means that the advisor also performs SQL Profiling analysis 
Time_limit: Time in seconds that the function can run.

The CREATE_TUNING_TASK function simply creates the task and returns either the task name that you have provided or generates a unique task name. This task name is the identifier by which you execute it (or perform other procedures upon it). To view the task names associated with a specific owner, you can run the following: 
select task_name from dba_advisor_log where owner='SH'; 

Execute the tuning task.: 
Execute dbms_sqltune.Execute_tuning_task (task_name => 'TEST_sql_tuning_task');

Check the status of the task using following query: 
 select status from dba_advisor_log where task_name='TEST_sql_tuning_task';

View the Recommendations 
set long 65536
set longchunksize 65536
set linesize 100
select dbms_sqltune.report_tuning_task('TEST_sql_tuning_task') from dual;

The output of above will be like this: 
DBMS_SQLTUNE.REPORT_TUNING_TASK('TEST_SQL_TUNING_TASK')
--------------------------------------------------------------------------------
GENERAL INFORMATION SECTION
-------------------------------------------------------------------------------
Tuning Task Name   : TEST_sql_tuning_task
Scope              : COMPREHENSIVE
Time Limit(seconds): 60
Completion Status  : COMPLETED
Started at         : 02/04/2004 23:17:49
Completed at       : 02/04/2004 23:18:19

-------------------------------------------------------------------------------
SQL ID  : 9bxw71yp99fr6

DBMS_SQLTUNE.REPORT_TUNING_TASK('TEST_SQL_TUNING_TASK')
--------------------------------------------------------------------------------

SQL Text: SELECT * FROM sales WHERE prod_id = 10 AND cust_id = 100

-------------------------------------------------------------------------------
FINDINGS SECTION (5 findings)
-------------------------------------------------------------------------------

1- Statistics Finding
---------------------
  Index "SH"."SALES_PROMO_BIX" was not analyzed.

  Recommendation

DBMS_SQLTUNE.REPORT_TUNING_TASK('TEST_SQL_TUNING_TASK')
--------------------------------------------------------------------------------
    Consider collecting optimizer statistics for this index.
    execute dbms_stats.gather_index_stats(ownname => 'SH', indname =>
            'SALES_PROMO_BIX', estimate_percent =>


SQL tuning information views, such as DBA_SQLTUNE_STATISTICS, DBA_SQLTUNE_BINDS, and DBA_SQLTUNE_PLANS views can also be queried to get this information.

Note: it is possible for the SQL Tuning Advisor to return no recommendations for a particular SQL statement e.g. in cases where the plan is already optimal or the Automatic Tuning Optimization mode cannot find a better plan.

=============================
To see status of tuning task
==============================

select task_name, status, sofar, totalwork from dba_advisor_tasks join v$advisor_progress using(task_id) where task_name = 'rjb_sql_tuning_task';

TASK_NAME           STATUS          SOFAR TOTALWORK
------------------------------ ----------- ---------- ----------
rjb_sql_tuning_task COMPLETED             1 1
SQL>

===============================
SQL Tuning Advisor for SQL_ID
=================================

1. Create SQL Tuning Advisor task
DECLARE
  my_task_name VARCHAR2(30);
begin
my_task_name := DBMS_SQLTUNE.CREATE_TUNING_TASK(sql_id => '7a6b4442j5pcz',scope => 'COMPREHENSIVE',time_limit => 60,task_name => 'STA:7a6b4442j5pcz',description => '7a6b4442j5pcz');
end;
/

2. Run Task 
EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => 'STA:7a6b4442j5pcz');

3. View results 
SET LONG 10000
SET PAGESIZE 1000
SET LINESIZE 200
SELECT DBMS_SQLTUNE.REPORT_TUNING_TASK('STA:7a6b4442j5pcz') from dual;

DBMS_SQLTUNE.REPORT_TUNING_TASK('STA:7A6B4442J5PCZ')
--------------------------------------------------------------------------------
GENERAL INFORMATION SECTION
----------------------------------------------------------------------------
---
Tuning Task Name                  : STA:7a6b4442j5pcz
Tuning Task Owner                 : SYS
Scope                             : COMPREHENSIVE
Time Limit(seconds)               : 60
Completion Status                 : COMPLETED
Started at                        : 10/16/2012 19:47:
27
Completed at                      : 10/16/2012 19:47:54
Number of SQL Profile Findings    : 1

----------------------------------------------------------

FINDINGS SECTION (1 finding)
--------------------------------------------------------------------
-----------

1- SQL Profile Finding (see explain plans section below)
--------------------------------------------------------
  A potentially better execution plan was found for thi
s statement.

  Recommendation (estimated benefit: 99.94%)
  ------------------------------------------
  - Consider accepting the recommended SQL profile.
    execute dbms_sqltune.accept_sql_profile(task_nam
e => 'STA:7a6b4442j5pcz',
            replace => TRUE);

=============================
How to ZIP/UNZIP on SOLARIS
==============================

gzip 'file name'
gunzip 'filename.gz'

$ gzip 'MANINFP3.20130508'
$ gunzip 'MANINFP3.20130508.gz'

===============================
REDO LOG file sizes
================================

SQL> select l.group#,f.member,l.archived,l.bytes/1078576 bytes,l.status,f.type from v$log l, v$logfile f where l.group# = f.group#;

==================================
Auto Stats collection by default
===================================

SQL> select CLIENT_NAME,STATUS from dba_autotask_client where client_name = 'auto optimizer stats collection';

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto optimizer stats collection                                  DISABLED

SQL> select client_name, status, attributes from dba_autotask_client;

CLIENT_NAME                              STATUS   ATTRIBUTES
---------------------------------------- -------- ------------------------------------------------------------
auto optimizer stats collection          ENABLED  ON BY DEFAULT, VOLATILE, SAFE TO KILL
auto space advisor                       ENABLED  ON BY DEFAULT, VOLATILE, SAFE TO KILL
sql tuning advisor                       DISABLED ONCE PER WINDOW, ON BY DEFAULT, VOLATILE, SAFE TO KILL

Disable auto stats collection
======================
BEGIN   
DBMS_AUTO_TASK_ADMIN.disable( client_name => 'auto optimizer stats collection',     operation   => NULL,     window_name => NULL); 
END; 
/ 

Set/UNSET LINE NUMBER in UNIX
=====================
:set number
:set nonumber

Current SCN finding
================
SQL> select current_scn from v$database;

CURRENT_SCN
-----------
1.24235E+13

SQL> select to_char(current_scn) from v$database;

TO_CHAR(CURRENT_SCN)
----------------------------------------
12423526338653

================================================
Disable jobs under dba_jobs
=================================================

Disable => dbms_job.broken
Delete => dbms_job.remove
 
 
begin
   exec dbms_job.broken(49,TRUE,sysdate); ==> DEFAULT is sysdate
   commit;
end;
/
 
begin
   exec dbms_job.remove(21);
   commit;
end;
/
 

SQL> exec dbms_job.broken(20,TRUE,sysdate);

PL/SQL procedure successfully completed.

SQL> commit;

Commit complete.

SQL> exec dbms_job.remove(20);

PL/SQL procedure successfully completed.

SQL> commit;

Commit complete.



=============================================
Archivelog details
=================================================

select SEQUENCE#,to_char(completion_time,'DD-MM-YYYY HH24:MI:SS' ) from v$archived_log;

More details on below link --> https://forums.oracle.com/thread/2221427

==============================================================
To check oracle is 32 bit or 64 bit
========================================


$ cd $ORACLE_HOME/bin
$ file oracle ==> If this command does not show any outout then it is 32 bit. iF it is 62 bit it will show below output
oracle:         ELF 64-bit MSB executable SPARCV9 Version 1, dynamically linked, not stripped
$ read

=============================================
To see AUTOCOMMIT is enabled or not
===========================================
SQL> conn @sgcfcd1
Connected.
SQL> select * from global_name;

GLOBAL_NAME
---------------------
SGCFCD1

SQL> sho autocommit;
autocommit OFF ==> AUTO COMMIT disabled

=====================================================
CPU USAGE
=============================


select s.username "Oracle User",s.osuser "OS User",i.consistent_gets "Consistent Gets",
i.physical_reads "Physical Reads",s.status "Status",s.sid "SID",s.serial#
"Serial#",
s.machine "Machine",s.program "Program",to_char(logon_time, 'DD/MM/YYYY
HH24:MI:SS') "Logon Time",
w.seconds_in_wait "Idle Time", P.SPID "PROC",
name "Stat CPU", value
from v$session s, v$sess_io i, v$session_wait w, V$PROCESS P, v$statname n,
v$sesstat t
where s.sid = i.sid
and s.sid = w.sid (+)
and 'SQL*Net message from client' = w.event(+)
and s.osuser is not null
and s.username is not null
and s.paddr=p.addr
and n.statistic# = t.statistic#
and n.name like '%cpu%'
and t.SID = s.sid
order by 6 asc, 3 desc, 4 desc

=======================
-- ***********************************************************
-- Display db cache cache advice
-- ***********************************************************
 ==============================================
 
column c1   heading 'Cache Size (meg)'      format 999,999,999,999 
column c2   heading 'Buffers'               format 999,999,999 
column c3   heading 'Estd Phys|Read Factor' format 999.90 
column c4   heading 'Estd Phys| Reads'      format 999,999,999 

select
   size_for_estimate          c1, 
   buffers_for_estimate       c2,
   estd_physical_read_factor  c3, 
   estd_physical_reads        c4
from
   v$db_cache_advice 
where
   name = 'DEFAULT'
and
   block_size  = (SELECT value FROM V$PARAMETER 
                   WHERE name = 'db_block_size')
and
   advice_status = 'ON';


=========================================================================

These statistics show whether the log_buffer is well sized.
==========================================================================
conn / as sysdba
set echo off
@save_sqlplus_settings

set termout off
column log_block_size new_value LogBlockSize
select
  max(lebsz) log_block_size
from
  sys.x$kccle
where
  inst_id = userenv('Instance')
/
set termout on

column write_size format 99999999999999 heading "Average Log|Write Size"

select
  ceil(max(decode(name, 'redo blocks written', value))
      /max(decode(name, 'redo writes', value, 1)))
  * &LogBlockSize  write_size
from
  sys.v_$sysstat
/

column threshold  format 99999999999999 heading "Background|Write Theshold"

select
  least(ceil(value/&LogBlockSize/3) * &LogBlockSize, 1024*1024)  threshold
from
  sys.v_$parameter
where
  name = 'log_buffer'
/

column sync_cost_ratio format 990.00 heading "Sync Cost Ratio"

select
  (sum(decode(name, 'redo synch time', value)) / sum(decode(name, 'redo synch writes', value)))
  / (sum(decode(name, 'redo write time', value)) / sum(decode(name, 'redo writes', value)))
    sync_cost_ratio
from
  sys.v_$sysstat
where
  name in ('redo synch writes', 'redo synch time', 'redo writes', 'redo write time')
/

@@sqlplus_settings
set echo on
conn /

======================================================
Dynamic query to get ddl's
====================================

select 'select dbms_metadata.get_ddl('''||OBJECT_TYPE||''','''||OBJECT_NAME||''',''FUN1DEQ2'') from dual;' FROM DBA_OBJECTS WHERE OWNER='FUN1DEQ2' AND OBJECT_TYPE='INDEX';

=====================================
Dynamic queries to compile all objects
======================================

set heading off
set feedback off
spool INV_OBJ.sql
select 'ALTER PACKAGE '|| owner ||'.'||object_name||' COMPILE body;' from dba_objects where status='INVALID' and object_type = 'PACKAGE BODY';
select 'ALTER PACKAGE '|| owner ||'.'||object_name||' COMPILE;' from dba_objects where status='INVALID' and object_type = 'PACKAGE';
select 'ALTER FUNCTION '|| owner ||'.'||object_name||' COMPILE;' from dba_objects where status='INVALID' and object_type like 'FUNCTION%';
select 'ALTER PROCEDURE '|| owner ||'.'||object_name||' COMPILE;' from dba_objects where status='INVALID' and object_type like 'PROCEDURE%';
select 'ALTER TRIGGER '|| owner ||'.'||object_name||' compile;' from dba_objects where status = 'INVALID' and object_type like 'TRIGGER%';
select 'ALTER VIEW '|| owner ||'.'||object_name||' COMPILE;' from dba_objects where status='INVALID' and object_type='VIEW';
select 'ALTER MATERIALIZED VIEW '|| owner ||'.'||object_name||' COMPILE;' from dba_objects where status='INVALID' and object_type='MATERIALIZED VIEW';

spool off

===================
ddl of MAT VIEWS
====================

 select dbms_metadata.get_ddl('MATERIALIZED_VIEW','COMPANY#') FROM DUAL;

=======================
DDL of JOBS/SCHEDULER
======================

SELECT dbms_metadata.get_ddl('PROCOBJ','YOURJOBNAME', 'YOURJOBOWNER') from dual;

Do not change --> PROCOBJ. Keep it as it is and give your job name and job owner.

================================
To check JOBS/SCHEDULER history
=================================

col JOB_NAME for a25;
col OWNER for a15;
col ACTUAL_START_DATE for a25;
col RUN_DURATION for a25;
col CPU_USED for a25;
col STATUS for a15;
col SESSION_ID for a25;

select OWNER,JOB_NAME,STATUS,to_char(ACTUAL_START_DATE,'YYYY-MM-DD HH24:MI:SS') "START TIME",RUN_DURATION,INSTANCE_ID,SESSION_ID,CPU_USED from dba_SCHEDULER_JOB_RUN_DETAILS where JOB_NAME='&jobname' order by "START TIME" desc; 

Job creation via scheduler
===========================

DBMS_METADATA.GET_DDL('PROCOBJ','BPCLNLP_STATS_JOB_SATURDAY','BPCLDBA')
--------------------------------------------------------------------------------

BEGIN
dbms_scheduler.create_job('"BPCLNLP_STATS_JOB_SATURDAY"',
job_type=>'PLSQL_BLOCK', job_action=>
'BEGIN dbms_stats.gather_schema_stats(''BPCLNLP'',cascade=>TRUE,degree=>6); END;',
number_of_arguments=>0,
start_date=>TO_TIMESTAMP_TZ('19-FEB-2018 06.57.11.859847000 PM +05:30',
'DD-MON-RRRR HH.MI.SSXFF AM TZR','NLS_DATE_LANGUAGE=english'), 
repeat_interval=>'freq=daily;byhour=23;byminute=0; bysecond=0',end_date=>NULL,
job_class=>'"DEFAULT_JOB_CLASS"', enabled=>FALSE, auto_drop=>TRUE,
comments=>'BPCLNLP_SCHEMA_STATS_JOB_SATURDAY');
COMMIT;
END;
/

JOb enabling
============= 

begin
DBMS_SCHEDULER.enable(name => '"BPCLNLP"."SAP_POSTING_OF_18_24"');
end;
/

PL/SQL procedure successfully completed.

SQL> SELECT owner, job_name, enabled FROM dba_scheduler_jobs;

OWNER                          JOB_NAME                       ENABL
------------------------------ ------------------------------ -----
BPCLDBA                        BPCLNLP_STATS_JOB_SATURDAY     TRUE

JOb disabling
============= 

SQL> begin
  2  DBMS_SCHEDULER.disable(name => '"BPCLDBA"."BPCLNLP_STATS_JOB_SATURDAY"');
  3  end;
  4  /

PL/SQL procedure successfully completed.

SQL> SELECT owner, job_name, enabled FROM dba_scheduler_jobs;

OWNER                          JOB_NAME                       ENABL
------------------------------ ------------------------------ -----
BPCLDBA                        BPCLNLP_STATS_JOB_SATURDAY     FALSE

32 rows selected.

dropping a job
======================= 

begin
DBMS_SCHEDULER.drop_job(job_name => '"BPCLDBA"."BSLN_MAINTAIN_STATS_JOB"');
end;
/

PL/SQL procedure successfully completed. 


To get ddl of a job ( https://dbaclass.com/article/get-ddl-dbms-scheduler-job/)
===================== 
select dbms_metadata.get_ddl('PROCOBJ','<<JOB NAME>>','<JOB OWNER>') from dual; 

if the owner is sys, then copy the scheduler job to another schema

exec dbms_scheduler.copy_job('SYS.CLEANUP_ONLINE_IND_BUILD','DBACLASS.CLEANUP_ONLINE_IND_BUILD');

then fire our usual command

select dbms_metadata.get_ddl('PROCOBJ','CLEANUP_ONLINE_IND_BUILD','DBACLASS') from dual;


TO get ddl of a job. This is for dbms_jobs. Not for dbms_scheduler_jobs.
=====================
First we need to export the job details with job number like below.

declare
    job_body varchar2(32767);
 begin
  dbms_job.user_export(<job id>,job_body); #enter job id here
  dbms_output.put_line(job_body);
  end;
  /
  
  Dbms_job.isubmit(job=>223,what=>'dbms_refresh.refresh(''"REPTUSER"."MV_NLP_SAP_DETAIL"'');',next_date=>to_date('2019-05-23:12:35:47','YYYY-MM-DD:HH24:MI:SS'),interval=>'SYSDATE + 1/48
',no_parse=>TRUE);
 

JOB creation
================

variable job number
exec dbms_job.submit(:job,'begin dbms_refresh.refresh(''"REPTUSER"."MV_SAP_RSP"''); end;', sysdate,'trunc(sysdate)+1/48');

(OR)

VARIABLE jobno number;
BEGIN
   DBMS_JOB.SUBMIT(:jobno, 'dbms_ddl.analyze_object(''TABLE'',''DQUON'', ''ACCOUNTS'', ''ESTIMATE'', NULL, 50);' SYSDATE, 'SYSDATE + 1');
    COMMIT;
END;
/
Statement processed.

print jobno
JOBNO
----------
14144








===============================================
To check whether reorg is required or not
===============================================
select
a.owner,
a.segment_name,
a.segment_type,
round(a.bytes/1024/1024,0) MBS,
round((a.bytes-(b.num_rows*b.avg_row_len) )/1024/1024,0) WASTED
from dba_segments a, dba_tables b
where a.owner=b.owner
and a.owner not like 'SYS%'
and a.segment_name = b.table_name
and a.segment_type='TABLE'
group by a.owner, a.segment_name, a.segment_type, round(a.bytes/1024/1024,0) ,round((a.bytes-(b.num_rows*b.avg_row_len) )/1024/1024,0)
having round(bytes/1024/1024,0) >100
order by round(bytes/1024/1024,0) desc ;

=========================================
HCL ORACLE related scripts placed here
==========================================

/net/build/export/DBdatabase/DBoracle/scripts/DB_TOOLS_PRIV.sql
/net/build/export/DBdatabase/DBoracle/DBglobaltools/standard_packages/site/refresh

============================
Without histogram stats collection
============================

For without histogram stats collection use ==> ( method_opt => 'FOR ALL COLUMNS SIZE 1') in stats collection script

check below query. it should be NONE for histogram

SQL> select distinct histogram from  all_tab_col_statistics where table_name = 'AI_ODS_RAW_MSG_TBL';

HISTOGRAM
---------------
NONE

Complete DDL of a user along with roles and privs
======================================

select (case
 when ((select count(*)
 from dba_users
 where username = '&&Username') > 0)
 then dbms_metadata.get_ddl ('USER', '&&Username')
 else to_clob (' -- Note: User not found!')
 end ) Extracted_DDL from dual
 UNION ALL
 select (case
 when ((select count(*)
 from dba_ts_quotas
 where username = '&&Username') > 0)
 then dbms_metadata.get_granted_ddl( 'TABLESPACE_QUOTA', '&&Username')
 else to_clob (' -- Note: No TS Quotas found!')
 end ) from dual
 UNION ALL
 select (case
 when ((select count(*)
 from dba_role_privs
 where grantee = '&&Username') > 0)
 then dbms_metadata.get_granted_ddl ('ROLE_GRANT', '&&Username')
 else to_clob (' -- Note: No granted Roles found!')
 end ) from dual
 UNION ALL
 select (case
 when ((select count(*)
 from dba_sys_privs
 where grantee = '&&Username') > 0)
 then dbms_metadata.get_granted_ddl ('SYSTEM_GRANT', '&&Username')
 else to_clob (' -- Note: No System Privileges found!')
 end ) from dual
 UNION ALL
 select (case
 when ((select count(*)
 from dba_tab_privs
 where grantee = '&&Username') > 0)
 then dbms_metadata.get_granted_ddl ('OBJECT_GRANT', '&&Username')
 else to_clob (' -- Note: No Object Privileges found!')
 end ) from dual
 /


=============================================
USERS / ROLES/ PRIVS in one shot
===============================================

Link : http://www.adp-gmbh.ch/ora/misc/recursively_list_privilege.html 

select
  lpad(' ', 2*level) || granted_role "User, his roles and privileges"
from
  (
  /* THE USERS */
    select 
      null     grantee, 
      username granted_role
    from 
      dba_users
    where
      username like upper('%&enter_username%')
  /* THE ROLES TO ROLES RELATIONS */ 
  union
    select 
      grantee,
      granted_role
    from
      dba_role_privs
  /* THE ROLES TO PRIVILEGE RELATIONS */ 
  union
    select
      grantee,
      privilege
    from
      dba_sys_privs
  )
start with grantee is null
connect by grantee = prior granted_role;

output
--------
Enter value for enter_username: GGATE
old  12:       username like upper('%&enter_username%')
new  12:       username like upper('%GGATE%')

User, his roles and privileges
--------------------------------------------------------------------------------
  GGATE
    GGATE_ACCESS_ROLE
    GGATE_OWNER_ROLE
      CREATE SESSION
      CREATE SYNONYM
      SELECT ANY DICTIONARY

=======================================================================================================
System privilages to roles and users - You need to give privilage. The output is, that privilage is assigned to which role and to which user 
==========================================================================================================
 
select
  lpad(' ', 2*level) || c "Privilege, Roles and Users"
from
  (
  /* THE PRIVILEGES */
    select 
      null   p, 
      name   c
    from 
      system_privilege_map
    where
      name like upper('%&enter_privliege%')
  /* THE ROLES TO ROLES RELATIONS */ 
  union
    select 
      granted_role  p,
      grantee       c
    from
      dba_role_privs
  /* THE ROLES TO PRIVILEGE RELATIONS */ 
  union
    select
      privilege     p,
      grantee       c
    from
      dba_sys_privs
  )
start with p is null
connect by p = prior c;

OUTPUT
----------

Enter value for enter_privliege: ALTER TABLE
old  12:       name like upper('%&enter_privliege%')
new  12:       name like upper('%ALTER TABLE%')

Privilege, Roles and Users
-----------------------------
  ALTER TABLESPACE
    DBA
      DB_TOOLS_PRIV
      ORACLE
      SYS
      SYSTEM
    SYS


====================== 
Object privilages
========================
 
select
  case when level = 1 then own || '.' || obj || ' (' || typ || ')' else
  lpad (' ', 2*(level-1)) || obj || nvl2 (typ, ' (' || typ || ')', null)
  end
from
  (
  /* THE OBJECTS */
    select 
      null          p1, 
      null          p2,
      object_name   obj,
      owner         own,
      object_type   typ
    from 
      dba_objects
    where
       owner not in 
        ('SYS', 'SYSTEM', 'WMSYS', 'SYSMAN','MDSYS','ORDSYS','XDB', 'WKSYS', 'EXFSYS', 
         'OLAPSYS', 'DBSNMP', 'DMSYS','CTXSYS','WK_TEST', 'ORDPLUGINS', 'OUTLN')
      and object_type not in ('SYNONYM', 'INDEX')
  /* THE OBJECT TO PRIVILEGE RELATIONS */ 
  union
    select
      table_name p1,
      owner      p2,
      grantee,
      grantee,
      privilege
    from
      dba_tab_privs
  /* THE ROLES TO ROLES/USERS RELATIONS */ 
  union
    select 
      granted_role  p1,
      granted_role  p2,
      grantee,
      grantee,
      null
    from
      dba_role_privs
  )
start with p1 is null and p2 is null
connect by p1 = prior obj and p2 = prior own;

=======================================
MEMORY TUNING
=======================================
select * from  v$sga_target_advice;
select * from  v$pga_target_advice;
select * from  v$memory_target_advice;

============================
SQL Tuning
============================
@$ORACLE_HOME/rdbms/admin/sqltrpt.sql ==> SQL Tuning advisor

select NAME,VERSION,DETECTED_USAGES,CURRENTLY_USED,LAST_USAGE_DATE from dba_feature_usage_statistics; ==> To check dba_feature_usage_statistics

==================
UNDO Tuning
===================
@$ORACLE_HOME}/rdbms/admin/dbmsuadv.sql ==> Undo advisor

===================
Segment Advisor - TABLE
===================

DECLARE
  l_object_id  NUMBER;
BEGIN
  DBMS_ADVISOR.create_task (
    advisor_name      => 'Segment Advisor',
    task_name         => 'AI_ODS',
    task_desc         => 'Segment Advisor For AI_ODS_PRE_RAW_MSG_TBL_E3ASIA');

  DBMS_ADVISOR.create_object (
    task_name   => 'AI_ODS',
    object_type => 'TABLE',
    attr1       => 'ACCOUNTINFO', 
    attr2       => 'AI_ODS_PRE_RAW_MSG_TBL_E3ASIA', 
    attr3       => NULL, 
    attr4       => 'null',
    attr5       => NULL,
    object_id   => l_object_id);

  DBMS_ADVISOR.set_task_parameter (
    task_name => 'AI_ODS',
    parameter => 'RECOMMEND_ALL',
    value     => 'TRUE');

  DBMS_ADVISOR.execute_task(task_name => 'AI_ODS');
END;
/ 

To see the results of above query
---------------------------------

set lines 200 pages 300
col TASK_NAME for a10;
col OBJECT_TYPE for a10;
col SCHEMA for a10;
col OBJECT_NAME for a30;
col MESSAGE for a40;
col MORE_INFO for a40;

SELECT f.task_name,f.impact,o.type AS object_type,o.attr1 AS schema,o.attr2 AS object_name,f.message,f.more_info FROM dba_advisor_findings f JOIN dba_advisor_objects o ON f.object_id = o.object_id AND f.task_name = o.task_name WHERE  f.task_name='&EnterTaskname' ORDER BY f.task_name, f.impact DESC;

To shrink storage, fire below commands
-----------------------------------------

-- Enable row movement.
ALTER TABLE scott.emp ENABLE ROW MOVEMENT;

-- Recover space and amend the high water mark (HWM).
ALTER TABLE scott.emp SHRINK SPACE;

-- Recover space, but don't amend the high water mark (HWM).
ALTER TABLE scott.emp SHRINK SPACE COMPACT;

-- Recover space for the object and all dependant objects.
ALTER TABLE scott.emp SHRINK SPACE CASCADE;

-- Shrink a LOB segment.
ALTER TABLE table_name MODIFY LOB(lob_column) (SHRINK SPACE);

-- Shrink an IOT overflow segment.
ALTER TABLE iot_name OVERFLOW SHRINK SPACE;

========================
Segment Advisor - TABLESPACE
=========================

DECLARE
  l_object_id  NUMBER;
BEGIN
  DBMS_ADVISOR.create_task (
    advisor_name      => 'Segment Advisor',
    task_name         => 'USERS_SEGMENT_ADVISOR',
    task_desc         => 'Segment Advisor For USERS');

  DBMS_ADVISOR.create_object (
    task_name   => 'USERS_SEGMENT_ADVISOR',
    object_type => 'TABLESPACE',
    attr1       => 'AI_DATA', 
    attr2       => NULL, 
    attr3       => NULL, 
    attr4       => 'null',
    attr5       => NULL,
    object_id   => l_object_id);

  DBMS_ADVISOR.set_task_parameter (
    task_name => 'USERS_SEGMENT_ADVISOR',
    parameter => 'RECOMMEND_ALL',
    value     => 'TRUE');

  DBMS_ADVISOR.execute_task(task_name => 'USERS_SEGMENT_ADVISOR');
END;
/ 

To see the results of above query
---------------------------------

set lines 200 pages 300
col TASK_NAME for a10;
col OBJECT_TYPE for a10;
col SCHEMA for a10;
col OBJECT_NAME for a30;
col MESSAGE for a40;
col MORE_INFO for a40;

SELECT f.task_name,f.impact,o.type AS object_type,o.attr1 AS schema,o.attr2 AS object_name,f.message,f.more_info FROM dba_advisor_findings f JOIN dba_advisor_objects o ON f.object_id = o.object_id AND f.task_name = o.task_name WHERE  f.task_name='&EnterTaskname' ORDER BY f.task_name, f.impact DESC;

To shrink storage fire below commands
-----------------------------------------

-- Enable row movement.
ALTER TABLE scott.emp ENABLE ROW MOVEMENT;

-- Recover space and amend the high water mark (HWM).
ALTER TABLE scott.emp SHRINK SPACE;

-- Recover space, but don't amend the high water mark (HWM).
ALTER TABLE scott.emp SHRINK SPACE COMPACT;

-- Recover space for the object and all dependant objects.
ALTER TABLE scott.emp SHRINK SPACE CASCADE;

-- Shrink a LOB segment.
ALTER TABLE table_name MODIFY LOB(lob_column) (SHRINK SPACE);

-- Shrink an IOT overflow segment.
ALTER TABLE iot_name OVERFLOW SHRINK SPACE;

To find out corrupted block
======================
SELECT SEGMENT_TYPE,OWNER||'.'||SEGMENT_NAME FROM DBA_EXTENTS WHERE 117=FILE_ID and 234125 BETWEEN BLOCK_ID AND BLOCK_ID+BLOCKS -1; 

==================
cursor: pin S wait on X
==================

SELECT s.sid, t.sql_text
FROM v$session s, v$sql t
WHERE s.event LIKE '%cursor: pin S wait on X%'
AND t.sql_id = s.sql_id;


Datafile shrinking
================
set verify off
column file_name format a70 word_wrapped
column smallest format 999,990 heading "Smallest|Size|Poss."
column currsize format 999,990 heading "Current|Size"
column savings  format 999,990 heading "Poss.|Savings"
break on report
compute sum of savings on report
column value new_val blksize

select file_name,
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) smallest,
       ceil( blocks*&&blksize/1024/1024) currsize,
       ceil( blocks*&&blksize/1024/1024) -
       ceil( (nvl(hwm,1)*&&blksize)/1024/1024 ) savings
from dba_data_files a,
     ( select file_id, max(block_id+blocks-1) hwm
         from dba_extents
        group by file_id ) b
where a.file_id = b.file_id(+) order by savings desc;

Out put
======
                                                   Smallest
                                                       Size  Current    Poss.
FILE_NAME                                             Poss.     Size  Savings
-------------------------------------------------- -------- -------- --------
/u02/oradata/cpdevdb/cp_jrnl_idx3.dbf                13,697   32,708   19,011
/u02/oradata/cpdevdb/cp_jrnl_idx2.dbf                13,761   32,748   18,987
/u02/oradata/cpdevdb/cp_jrnl_idx1_01.dbf             13,953   32,748   18,795

shrink query
===========
alter database datafile '/u02/oradata/cpdevdb/cp_jrnl_idx3.dbf' resize 13700m;


LOAD Query (from satya)
====================
col SQL_TEXT for a40;
col EVENT for a20;
col MACHINE for a20;
col PROGRAM for a20;
select distinct (select value from v$osstat where stat_name='LOAD') load,LAST_CALL_ET,spid,sw.sid,S.event,sql_text ,s.program,s.machine,s.ROW_WAIT_OBJ# from v$session_wait sw,v$sql q,v$process p,v$session s where sw.sid=s.sid
and s.paddr=p.addr
and s.sql_HASH_VALUE=q.HASH_VALUE
and s.status='ACTIVE' ---and s.sid='3022'
AND s.USERNAME IS NOT NULL
ORDER BY 2 DESC;


MEMORY PARAMETERS RESET
========================

alter system set memory_target = 3G scope=spfile;
alter system reset pga_aggregate_target;
alter system reset sga_target;
alter system reset sga_max_size;
 
--> after the above settings you need to restart the database


Data Cache (DB_CACHE_SIZE) Hit ratio
=====================================

select sum(decode(name,’physical reads’,value,0)) phys,
 sum(decode(name,’db block gets’,value,0)) gets,
 sum(decode(name,’consistent gets’, value,0)) con_gets,
 (1 – (sum(decode(name,’physical reads’,value,0)) /
 (sum(decode(name,’db block gets’,value,0)) +
 sum(decode(name,’consistent gets’,value,0))))) * 100 hitratio
 from v$sysstat;
 
Physical Reads DB Block Gets Consistent Gets Hit Ratio
 ————– ————– ————— ———–--------------------------------------
 1,671                   39,561 71,142       98.49

Note : If the hit ratio is more than 95% then DB_CACHE_SIZE parameter is set to correct value


cpu usage by session
===========================

select
 aa.username,
 bb.SID,
 VALUE/100 cpu_usage_seconds
 from
 v$session a,
 v$sesstat b,
 v$statname c
 where
 b.STATISTIC# = c.STATISTIC#
 and
 NAME like ‘%CPU used by this session%’
 and
 b.SID = a.SID
 and
 a.status=’ACTIVE’
 and
 a.username is not null
 order by VALUE desc;

To see unrecoverable objects
========================
select distinct ss.owner,ss.object_name, ss.object_type,ss.tablespace_name, ts.logging tablespace_level_logging from v$segment_statistics ss, dba_tablespaces ts,v$datafile df where
ss.statistic_name='physical writes direct' and ss.value >0 and df.unrecoverable_change# >0 and ss.ts#=df.ts# and ss.tablespace_name=ts.tablespace_name;

To check hidden parameters
=======================

select name, value from sys.V$PARAMETER where name like '\_%' escape '\';


UNDO ADVISOR (http://maxwellmiranda.wordpress.com/2009/09/29/undo-informationdbms_undo_adv/)
===============================================================================================

SQL> select dbms_undo_adv.longest_query(sysdate-60,sysdate) from dual;

DBMS_UNDO_ADV.LONGEST_QUERY(SYSDATE-60,SYSDATE)
-----------------------------------------------
                                          36238

SQL> select dbms_undo_adv.required_retention from dual;

REQUIRED_RETENTION
------------------
             36238

SQL> select dbms_undo_adv.best_possible_retention from dual;

BEST_POSSIBLE_RETENTION
-----------------------
                   6143

SQL> select dbms_undo_adv.required_undo_size(36238) from dual;

DBMS_UNDO_ADV.REQUIRED_UNDO_SIZE(36238)
---------------------------------------
                                  65310

SQL> select dbms_undo_adv.required_undo_size(36238,sysdate-60,sysdate) from dual;

DBMS_UNDO_ADV.REQUIRED_UNDO_SIZE(36238,SYSDATE-60,SYSDATE)
----------------------------------------------------------
                                                     65310

TO GET FULL DETAILS OF UNDO
============================

set serveroutput on

DECLARE
prob VARCHAR2(100);
reco VARCHAR2(100);
rtnl VARCHAR2(100);
retn PLS_INTEGER;
utbs PLS_INTEGER;
retv PLS_INTEGER;
BEGIN
retv := dbms_undo_adv.undo_health(prob, reco, rtnl, retn, utbs);
dbms_output.put_line('Problem: ' || prob);
dbms_output.put_line('Recmmnd: ' || reco);
dbms_output.put_line('Rationl: ' || rtnl);
dbms_output.put_line('Retentn: ' || TO_CHAR(retn));
dbms_output.put_line('UTBSize: ' || TO_CHAR(utbs));
END
;
/


To check privilages on DBA_DIRECTORIES
======================================

select * from all_tab_privs where table_name = '<Directory name>';

Best value for SGA_TARGET if you are using manual allocation for memory parameters
===================================================================================


SQL> select ((select sum(value) from v$sga) - (select current_size from v$sga_dynamic_free_memory)) sga_target from dual;

SGA_TARGET
----------
 466231296 (Best value)

Then fire below commands

alter system set SHARED_POOL_SIZE = 0;
alter system set LARGE_POOL_SIZE = 0;
alter system set JAVA_POOL_SIZE = 0;
alter system set DB_CACHE_SIZE = 0;
alter system set STREAMS_POOL_SIZE = 0;


=============================
Switching from AMM to ASMM
===========================
alter system set memory_target = 0;

After you issue this command, Oracle automatically sets SGA_TARGET based on the current SGA memory usage.

=============
Metalink
==========
Oracle webinar session recordings --> 740966.1

======================================
Performance tuning best site
==============================

http://www.pythian.com/blog/case-study-dba-under-pressure-or-performance-troubleshooting-on-friday-13/

==============================
Database scripts
==============================


http://www.oracle-base.com/dba/Scripts.php
http://www.oraclescripts.com/
http://www.idevelopment.info/cgi/ORACLE_dba_scripts.cgi
http://www.dbatoolz.com/sql-scripts
http://www.dbasupport.com/oracle/scripts/
http://www.orafaq.com/wiki/Scripts
http://www.akadia.com/html/ora_scripts.html
http://www.shutdownabort.com/
http://www.dbapool.com/scripts.php
http://www.blacksheepnetworks.com/security/resources/www.think-forward.com/sqltips.htm
http://www.dbalifeline.com/content/oracle-scripts-generate-ddl-roles-and-users
http://www.databaseanswers.org/sql_scripts/index.htm
https://netfiles.uiuc.edu/jstrode/www/oscript/index.html
http://www.idevelopment.info/cgi/ORACLE_dba_tips.cgi
http://www.shutdownabort.com/scripts/
http://tech.e2sn.com/oracle-scripts-and-tools
http://toolkit.rdbms-insight.com/grants_script.php
http://www.dbspecialists.com/scripts.html
http://www.extraconnections.co.uk/code/oracle-scripts
http://vsbabu.org/oracle/
http://www.dba.bg/forum/forumdisplay.php?23-Oracle-Scripts
http://www.oriolecorp.com/scripts1.html
http://oriole.com/script_archive.shtml
http://freespace.virgin.net/bill.doyle/ora_scr.htm
http://appsdba.com/scripts_sql.htm
http://oracleonline.info/Oracle_Dba_scripts.html
http://www.tc.umn.edu/~hause011/code/exp-imp-db.ksh
http://dbahelp.co.uk/ora_scripts.aspx
http://www.ixora.com.au/scripts/
http://www.bgs-soft.com/scripts/move_segments.asp
http://www.dbapool.com/dbscripts/script_32.html
http://mcastanho.com/mcastanhocombin/oracleresources.html
http://www.oracle-scripts.net/?p=273
http://dbametrix.net/map.php?forum=29&news
http://www.think-forward.com/oracle_space_management.htm
http://www.oradev.com/scripts.jsp
http://www.astral-consultancy.co.uk/cgi-bin/hunbug/doco.cgi?11400
http://www.dba-oracle.com/t_locked_rows_user_locks.htm
http://www.rampant-books.com/t_tracking_oracle_database_tables_growth.htm
http://www.articles.freemegazone.com/shrinking-oracle-datafiles.php

====================================================
History of SQL's executed on a perticular day/date
====================================================

SQL> col sql_text for a40
SQL> col sample_time for a15
SQL> ALTER SESSION SET nls_timestamp_format='DD-MON-RR HH24:MI';
 
Session altered.
 
SQL> SELECT hist.sql_id, hist.sql_text, sess.sample_time
  2  FROM dba_hist_sqltext hist, dba_hist_active_sess_history sess
3  WHERE hist.sql_id=sess.sql_id
  4  AND hist.dbid=sess.dbid
  5  AND hist.dbid=(SELECT dbid FROM v$database)
  6  AND hist.command_type=3
  7  AND sess.sample_time BETWEEN to_timestamp('15-DEC-14 08:00')
  8  AND to_timestamp('15-DEC-14 15:30')
  9  ORDER BY sess.sample_time DESC;
 
SQL_ID        SQL_TEXT                                SAMPLE_TIME            
------------- ---------------------------------------- ---------------        
ajymgnp1qnruw select o.name, o.owner# from obj$ o, typ 15-DEC-14 13:39        
              e$ t  where o.oid$ = t.tvoid and  bitand                        
                                                                              
4x2cynvsuuddu select /*+ FIRST_ROWS(1) */ x.C1, x.C2,  15-DEC-14 09:04        
              x.C3 from  (select a.obj# C1,          d                        
 
==============================
Good Oracle Videos
============================
skillbuilders.com

===========================
ASM Explained well video
===========================

https://www.youtube.com/watch?v=Xh4a_tcb1bc

https://www.youtube.com/watch?v=POQObhl-HyI ==> Installing Oracle RAC 11.2 on Oracle Linux 5.5

===========================================================================
To see whether default optimiser statistics collection enabled or disabled
===========================================================================

In 11g
====== 

SQL> SELECT client_name, status FROM dba_autotask_operation;

CLIENT_NAME                                                      STATUS
---------------------------------------------------------------- --------
auto optimizer stats collection                                  ENABLED
auto space advisor                                               ENABLED
sql tuning advisor                                               ENABLED

In 10g
=====

SQL> SELECT JOB_NAME, SCHEDULE_NAME, SCHEDULE_TYPE, ENABLED FROM DBA_SCHEDULER_JOBS WHERE PROGRAM_NAME = 'GATHER_STATS_PROG';




=====================================
Asm Disk lableing at os level
=====================================

CREATE DISKGROUP TEST EXTERNAL REDUNDANCY DISK '/dev/rdsk/c7t6d0s6' SIZE 24G ATTRIBUTE compatible.asm'='11.2.0.0.0','compatible.rdbms'='11.2.0.0.0','sector_size'='4096';

https://unixoracledba.wordpress.com/2012/04/15/adding-and-removing-disk-to-diskgroup/ ==> ASM DISK addition site


/etc/init.d/oracleasm createdisk ASMDATA7_3PAR  /dev/dm-22

ALTER DISKGROUP DATAVOL ADD DISK ‘/dev/oracleasm/dev/dm-22’ NAME ASMDATA7_3PAR  REBALANCE POWER 11;

(OR)

ALTER DISKGROUP DATAVOL add disk 'ORCL:ASMDATA7_3PAR' REBALANCE POWER 11; ==> ORCL we need to add infront of disk name

alter diskgroup DATA add disk ‘ORCL:DISK6’;


alter tablespace BUNDLETOP_DATA add datafile '+DATAVOL' size 500M;


https://community.oracle.com/thread/3534689?start=0&tstart=0
https://dbasolutions.wikispaces.com/ASMLIB+CONFIGURE,VERIFY,+TROUBLESHOOT
https://sites.google.com/site/oracledbnote/asmlib (Very good for oracle also)

oracle@mpluoradb.ffx.jfh.com.au:/home/oracle:+ASM > /usr/sbin/oracleasm-discover
Using ASMLib from /opt/oracle/extapi/64/asm/orcl/1/libasm.so
[ASM Library - Generic Linux, version 2.0.4 (KABI_V2)]
Discovered disk: ORCL:ASMDATA0_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA1_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA2_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA3_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA4_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA5_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA6_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMDATA7_3PAR [419430400 blocks (214748364800 bytes), maxio 512]
Discovered disk: ORCL:ASMREDO_3PAR [31457280 blocks (16106127360 bytes), maxio 512]
oracle@mpluoradb.ffx.jfh.com.au:/home/oracle:+ASM >





To see oracle asm rpm's installed
==========================

-bash-3.00$ rpm -qa |grep oracleasm

oracleasm-support-2.1.7-1.el4
oracleasmlib-2.0.4-1.el4
oracleasm-2.6.9-67.0.7.EL-2.0.3-1
oracleasm-2.6.9-67.EL-2.0.3-1
oracleasm-2.6.9-103.EL-2.0.5-1.el4

-bash-3.00$ rpm -qa --qf "%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}.rpm\n" | grep asm

oracleasm-support-2.1.7-1.el4.ia64.rpm
oracleasmlib-2.0.4-1.el4.ia64.rpm
oracleasm-2.6.9-67.0.7.EL-2.0.3-1.ia64.rpm
oracleasm-2.6.9-67.EL-2.0.3-1.ia64.rpm
oracleasm-2.6.9-103.EL-2.0.5-1.el4.ia64.rpm


-bash-3.00$ uname -a
Linux racnsw3-rh2 2.6.9-103.EL #1 SMP Fri Nov 11 14:23:29 EST 2011 ia64 ia64 ia64 GNU/Linux

based on the kernal version, we need to install--> oracleasm-2.6.9-103.EL-2.0.5-1.el4.ia64.rpm

oracleasm utility
=====================

Oracle ASM library (ASMLib) driver

#/etc/init.d/oracleasm start

#/etc/init.d/oracleasm stop

#/etc/init.d/oracleasm restart 

#/etc/init.d/oracleasm status


#/etc/init.d/oracleasm enable

#/etc/init.d/oracleasm disable



#/etc/init.d/oracleasm configure

#/etc/init.d/oracleasm createdisk DISK_NAME PARTITION_NAME
#/etc/init.d/oracleasm createdisk VOL3 /dev/sdd1
#/etc/init.d/oracleasm createdisk ASM_DATA /dev/cciss/c0d1p1

#/etc/init.d/oracleasm scandisks

#/etc/init.d/oracleasm listdisks

#/etc/init.d/oracleasm querydisk DISK_NAME
#/etc/init.d/oracleasm querydisk -d LABEL
#/etc/init.d/oracleasm querydisk /dev/sdc6
#/etc/init.d/oracleasm querydisk -d VOL6
#/etc/init.d/oracleasm querydisk -p VOL1

#/etc/init.d/oracleasm renamedisk PARTITION_NAME DISK_NAME
#/etc/init.d/oracleasm renamedisk /dev/sdc1 VOL2

#/etc/init.d/oracleasm deletedisk DISK_NAME
#/etc/init.d/oracleasm deletedisk /dev/sdc9


======================
Volume information
=====================

[root@usdadcgdbpl13 ~]# pvs ==> Physical volume info
  PV                  VG      Fmt  Attr PSize   PFree
  /dev/mapper/mpathas VGORA02 lvm2 a--   38.40g      0
  /dev/mapper/mpathbc VGORA02 lvm2 a--   38.40g      0
  /dev/mapper/mpathbk VGORA02 lvm2 a--   38.40g 808.00m
  /dev/mapper/mpathbr VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathbs VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathbt VGORA02 lvm2 a--   38.40g      0
  /dev/mapper/mpathbu VGORA02 lvm2 a--   38.40g      0
  /dev/mapper/mpathbv VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathbw VGORA01 lvm2 a--   38.40g 808.00m
  /dev/mapper/mpathbx VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathby VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathca VGORA01 lvm2 a--   38.40g      0
  /dev/mapper/mpathcb VGORA02 lvm2 a--   38.40g      0
  /dev/mapper/mpathcc VGORA02 lvm2 a--   38.40g      0
  /dev/sda2           VG00    lvm2 a--  136.40g      0

[root@usdadcgdbpl13 ~]# vgs ==> Volume groups
  VG      #PV #LV #SN Attr   VSize   VFree
  VG00      1   3   0 wz--n- 136.40g      0
  VGORA01   7   1   0 wz--n- 268.79g 808.00m
  VGORA02   7   1   0 wz--n- 268.79g 808.00m


[root@usdadcgdbpl13 ~]# lvs ==> Logical volume info
  LV             VG      Attr      LSize   Pool Origin Data%  Move Log Cpy%Sync Convert
  optvol         VG00    -wi-ao---  75.86g
  rootvol        VG00    -wi-ao---  29.30g
  swapvol        VG00    -wi-ao---  31.25g
  db_backup_grs2 VGORA01 -wi-ao--- 268.00g
  db_backup_cnsl VGORA02 -wi-ao--- 268.00g

[root@usdadcgdbpl13 ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/mapper/VG00-rootvol
                       29G   24G  3.6G  87% /
tmpfs                  64G  148M   63G   1% /dev/shm
/dev/sda1             291M   38M  239M  14% /boot
/dev/mapper/VG00-optvol
                       75G   61G   11G  86% /opt
/dev/mapper/VGORA01-db_backup_grs2
                      264G   35G  217G  14% /db_backup_grs2
/dev/mapper/VGORA02-db_backup_cnsl
                      264G  2.7G  248G   2% /db_backup_cnsl


======================================================
History of a SQL Query executed in between given time
=======================================================

--
-- List Session Details for a Given Time Period
--
-- s_time format = '22/OCT/2014 04:00:00.000' 
-- e_time format = '23/OCT/2014 04:00:00.000'  
-- inst_no = Instance Number for RAC.  Use 1 for non RAC
--
 
SET PAUSE ON
SET PAUSE 'Press Return To Continue'
SET HEADING ON
SET LINESIZE 300
SET PAGESIZE 60
 
COLUMN Sample_Time FOR A12
COLUMN username FOR A20
COLUMN sql_text FOR A40
COLUMN program FOR A40
COLUMN module FOR A40
 
SELECT
   sample_time,
   u.username,
   h.program,
   h.module,
   s.sql_text
FROM
   DBA_HIST_ACTIVE_SESS_HISTORY h,
   DBA_USERS u,
   DBA_HIST_SQLTEXT s
WHERE  sample_time
BETWEEN '&s_time' and '&e_time'
AND
   INSTANCE_NUMBER=&inst_no
   AND h.user_id=u.user_id
   AND h.sql_id = s.sql_iD
ORDER BY 1
/

------------------------------------------------------------
Another query of a SQL Query executed in between given time
---------------------------------------------------------------

select 
*
from DBA_HIST_ACTIVE_SESS_HISTORY
where 
sample_time 
between 
to_date('18-APR-2012 10:40:00','DD-MON-YYYY HH24:MI:SS')
and 
to_date('18-APR-2012 10:40:10','DD-MON-YYYY HH24:MI:SS')
and instance_number in (1,12)
order by sample_time,instance_number,SESSION_ID;

=========================================================================
DYNAMIC QUERY to enable auto extend for all data files of a tablespace
=============================================================================

select 'alter database datafile '|| file_name|| ' '|| ' autoextend on maxsize unlimited;' from dba_data_files where tablespace_name='&TABLESPACE';

=========================
Block corruption check
=========================


SET PAGESIZE 200
SET LINES 200
COL SEGMENT_NAME FOR A25
COL PARTITION_NAME FOR A20
COL owner for a15
SELECT e.owner, e.segment_type, e.segment_name, e.partition_name, c.file#
     , greatest(e.block_id, c.block#) corr_start_block#
     , least(e.block_id+e.blocks-1, c.block#+c.blocks-1) corr_end_block#
     , least(e.block_id+e.blocks-1, c.block#+c.blocks-1)
       - greatest(e.block_id, c.block#) + 1 blocks_corrupted
     , corruption_type description
  FROM dba_extents e, v$database_block_corruption c
 WHERE e.file_id = c.file#
   AND e.block_id <= c.block# + c.blocks - 1
   AND e.block_id + e.blocks - 1 >= c.block#;

==============================
ORA-00600 error - Diagnosis
=============================

In the oRA-00600 gives comments
	
the 1st is error code
2nd [234403] is the object id
3rfd is the block no [12696822]

ORA-00600: internal error code, arguments: [13011], [234403], [12696822], [6], [12696822], [17], [], [], [], [], [], []


13011 --> Error code
234403 --> Object iD
12696822 --> Block number

===============
Wait events - 1
==============

col EVENT for a30;
col WAIT_CLASS for a30;
select INST_ID,SID,EVENT,WAIT_CLASS,WAIT_TIME,SECONDS_IN_WAIT,STATE from  gv$session_wait where WAIT_CLASS!='Idle';


select INST_ID,SID,SERIAL#,USERNAME,STATUS,OSUSER,MACHINE,PROGRAM,SQL_ID,ROW_WAIT_OBJ#,BLOCKING_SESSION,EVENT from gv$session where SID in ();

select INST_ID,SID,SERIAL#,USERNAME,STATUS,OSUSER,MACHINE,PROGRAM,SQL_ID,ROW_WAIT_OBJ#,BLOCKING_SESSION,EVENT from gv$session where SID in (select SID from  gv$session_wait where WAIT_CLASS!='Idle');

===============
Wait events - 2
==============

col EVENT for a30;
col WAIT_CLASS for a30;
select INST_ID,SID,EVENT,WAIT_CLASS,WAIT_TIME,SECONDS_IN_WAIT,STATE from  gv$session_wait where WAIT_CLASS!='Idle';

SELECT wait_class_id, wait_class, total_waits, time_waited FROM gv$session_wait_class WHERE sid = &SID;

select event, total_waits, time_waited from gv$system_event e, gv$event_name n where n.event_id = e.event_id and e.wait_class_id = &WaitClassId;

Then go with

V$EVENT_HISTOGRAM – to determine whether the TIME_WAITED is evenly distributed across the occurrences of the wait or whether some waits for the events were very long whilst others were short indicating more erratic response times.


================================
Fentastic Wait event explanation
================================

https://sites.google.com/site/embtdbo/wait-event-documentation

Analysing Row Lock Contention with LogMiner - > https://antognini.ch/2012/03/analysing-row-lock-contention-with-logminer/



============================
DATABASE LOCKS - ROW LOCKS
============================

select  event,  p1, mod(p1,16)  as "mode" from gv$active_session_history where event like 'enq:%';


EVENT                                 P1 mode
----------------------------- ---------- ----
enq: TX - allocate ITL entry  1415053316    4
enq: TX - row lock contention 1415053318    6
enq: TX - row lock contention 1415053316    4


Table Contention - 10g onwards
--------------------------------

col file# for 99999999
col block# for 999999999
col obj for a30
col type for a20
col lm for 99
col bsid for 999999
col EVENT for a40;


select        count(*) cnt, 
              session_id sid,
              substr(event,1,30) event, 
              mod(p1,16)  as lm,
              sql_id,
              CURRENT_OBJ# || ' ' || object_name obj
            , o.object_type type
            , CURRENT_FILE# file#
            , CURRENT_BLOCK#  block#
            , blocking_session bsid
 from gv$active_session_history ash,
      all_objects o
 where
         event  like 'enq: T%'
   and o.object_id (+)= ash.current_obj#
group by event,session_id,p1,sql_ID,CURRENT_OBJ#,OBJECT_NAME,OBJECT_TYPE,CURRENT_FILE#, CURRENT_BLOCK#, BLOCKING_SESSION
order by  count(*)
/


INDEX Contention - 10g onwards
---------------------------------

col file# for 99999
col block# for 999999
col obj for a30
col type for a30

select     session_id sid, substr(event,1,30) event, sql_id,
          CURRENT_OBJ# || ' ' || object_name obj
        , o.object_type type
        , CURRENT_FILE# file#
        , CURRENT_BLOCK#  block#
 from v$active_session_history ash,
          ( select a.object_name, 
                   a.object_id,
                   decode(a.object_type,'INDEX',i.index_type||' '||'INDEX',a.object_type) object_type
            from all_objects a, all_indexes i where 
            a.owner=i.owner(+) and a.object_name=i.index_name(+) ) o
 where
         event  like 'enq: TX%'
   and o.object_id (+)= ash.current_obj#
 order by sample_time
/

Datapump interactive mode demo ( http://blog.oracle48.nl/killing-and-resuming-datapump-expdp-and-impdp-jobs/)
================================= ===============================================================================

1) Execute the command at command line
----------------------------------------
[oracle@vmlinora122 ~]$ impdp \'/ as sysdba\' directory=NBACKUP dumpfile=NBACKUP.dmp logfile=imp_NBACKUP.log remap_schema=TEST_ISO_EB_STAGING:ISODBA remap_tablespace=TEST_ISO_EB_STAGING_DATA:TEST_ISO_EB_STAGING_DATA job_name=impnagajob

Import: Release 12.2.0.1.0 - Production on Wed Apr 3 10:34:08 2019

Copyright (c) 1982, 2017, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production
Master table "SYS"."IMPNAGAJOB" successfully loaded/unloaded
Starting "SYS"."IMPNAGAJOB":  "/******** AS SYSDBA" directory=NBACKUP dumpfile=NBACKUP.dmp logfile=imp_NBACKUP.log remap_schema=TEST_ISO_EB_STAGING:ISODBA remap_tablespace=TEST_ISO_EB_STAGING_DATA:TEST_ISO_EB_STAGING_DATA job_name=impnagajob
Processing object type SCHEMA_EXPORT/USER
ORA-31684: Object type USER:"ISODBA" already exists

Processing object type SCHEMA_EXPORT/SYSTEM_GRANT
Processing object type SCHEMA_EXPORT/ROLE_GRANT
Processing object type SCHEMA_EXPORT/DEFAULT_ROLE
Processing object type SCHEMA_EXPORT/TABLESPACE_QUOTA
Processing object type SCHEMA_EXPORT/PRE_SCHEMA/PROCACT_SCHEMA
Processing object type SCHEMA_EXPORT/DB_LINK
Processing object type SCHEMA_EXPORT/SYNONYM/SYNONYM
Processing object type SCHEMA_EXPORT/SEQUENCE/SEQUENCE
Processing object type SCHEMA_EXPORT/TABLE/TABLE
Processing object type SCHEMA_EXPORT/TABLE/TABLE_DATA
. . imported "ISODBA"."POSITION_FACTS"                   344.7 MB 7291462 rows
. . imported "ISODBA"."STG_PARTICIPATION"                211.6 MB 8479497 rows

^C   << PRESS CTRL C >>

2) Once after pressing ctrl+c it enters into interactive mode and command prompt is import> like below
Import> 

3) Stop the job now with stop_job command
Import> stop_job
Are you sure you wish to stop this job ([yes]/no): yes

4) After some time you RESUME the job first by attaching the job name

[oracle@vmlinora122 ~]$ impdp \'/ as sysdba\' attach=IMPNAGAJOB <== Job name

Import: Release 12.2.0.1.0 - Production on Wed Apr 3 10:37:26 2019

Copyright (c) 1982, 2017, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

Job: IMPNAGAJOB
  Owner: SYS
  Operation: IMPORT
  Creator Privs: TRUE
  GUID: 859D1E0A5A6E6821E0537A1E518A0F38
  Start Time: Wednesday, 03 April, 2019 10:37:27
  Mode: FULL
  Instance: TESTDB1
  Max Parallelism: 1

6) Start the job now with start_job command 

Import> start_job

7) If you want to see the log messages, type continue_client

Import> continue_client

Job IMPNAGAJOB has been reopened at Wed Apr 3 10:37:27 2019
Restarting "SYS"."IMPNAGAJOB":  "/******** AS SYSDBA" directory=NBACKUP dumpfile=NBACKUP.dmp logfile=imp_NBACKUP.log remap_schema=TEST_ISO_EB_STAGING:ISODBA remap_tablespace=TEST_ISO_EB_STAGING_DATA:TEST_ISO_EB_STAGING_DATA job_name=impnagajob
Processing object type SCHEMA_EXPORT/TABLE/CONSTRAINT/CONSTRAINT
Processing object type SCHEMA_EXPORT/TABLE/INDEX/STATISTICS/INDEX_STATISTICS
Processing object type SCHEMA_EXPORT/TABLE/CONSTRAINT/REF_CONSTRAINT
Processing object type SCHEMA_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS
Processing object type SCHEMA_EXPORT/STATISTICS/MARKER
Processing object type SCHEMA_EXPORT/POST_SCHEMA/PROCOBJ
Job "SYS"."IMPNAGAJOB" completed with 1 error(s) at Wed Apr 3 10:39:22 2019 elapsed 0 00:01:55

[oracle@vmlinora122 ~]$





To stop a datapump job explicitely (Even if it is running after killing process at unix prompt)
================================================================================================

DECLARE
h1 NUMBER;
BEGIN
h1:=DBMS_DATAPUMP.ATTACH('EXP_OUTOEXP_1','SYS');
DBMS_DATAPUMP.STOP_JOB (h1,1,0);
END;
/

and then check below

col OPERATION for a30;
col JOB_MODE for a20;
col OWNER_NAME for a30
col job_name for a30
col state for a30;

select OWNER_NAME,JOB_NAME,OPERATION,JOB_MODE,STATE from dba_datapump_jobs order by STATE;

Monitor Datapump job - 1
================
select sid, serial#, sofar, totalwork,dp.owner_name,dp.job_name,dp.state, dp.job_mode from gv$session_longops sl, gv$datapump_job dp where sl.opname = dp.job_name and sofar != totalwork;

      SID    SERIAL#      SOFAR  TOTALWORK OWNER_NAME                     STATE                          JOB_MODE
---------- ---------- ---------- ---------- ------------------------------ ------------------------------ ------------------------------
       702      43301     264742    1127995 SYS                            EXECUTING                      FULL



Monitor Datapump job - 2
================
select sid, serial#, sofar, totalwork from   v$session_longops where  opname = '&datapump_job>' and  sofar != totalwork;


=================================================
HOW TO DROP DATAPUMP jobs which are NOT Running  (Doc ID 336014.1) and https://pavandba.com/2011/07/12/how-to-deleteremove-non-executing-datapump-jobs/
=================================================

[oracle@s01opvdbaa44n02 ~]$ sqlplus / as sysdba

Connected to:
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

SQL> sho pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
         2 PDB$SEED                       READ ONLY  NO
         3 MAXP                           READ WRITE NO
SQL> alter session set container=MAXP;

Session altered.

SET LINES 200 PAGES 300
col OPERATION for a30;
col JOB_MODE for a20;
col OWNER_NAME for a30
col job_name for a30
col state for a30;
select OWNER_NAME,JOB_NAME,OPERATION,JOB_MODE,STATE from dba_datapump_jobs order by STATE;

OWNER_NAME                     JOB_NAME                       OPERATION                      JOB_MODE             STATE
------------------------------ ------------------------------ ------------------------------ -------------------- ------------------------------
SYSTEM                         SYS_EXPORT_SCHEMA_02           EXPORT                         SCHEMA               NOT RUNNING
SYSTEM                         SYS_EXPORT_SCHEMA_01           EXPORT                         SCHEMA               NOT RUNNING
SYSTEM                         SYS_EXPORT_SCHEMA_03           EXPORT                         SCHEMA               NOT RUNNING

col OWNER.OBJECT for a30
SELECT o.status, o.object_id, o.object_type,o.owner||'.'||object_name "OWNER.OBJECT" FROM dba_objects o, dba_datapump_jobs j WHERE o.owner=j.owner_name AND o.object_name=j.job_name   AND j.job_name NOT LIKE 'BIN$%' ORDER BY 4,2;

STATUS   OBJECT_ID OBJECT_TYPE             OWNER.OBJECT
------- ---------- ----------------------- ------------------------------
VALID       238501 TABLE                   SYSTEM.SYS_EXPORT_SCHEMA_01
VALID       238532 TABLE                   SYSTEM.SYS_EXPORT_SCHEMA_02
VALID       272465 TABLE                   SYSTEM.SYS_EXPORT_SCHEMA_03

SQL> drop table SYSTEM.SYS_EXPORT_SCHEMA_01;

Table dropped.

SQL> drop table SYSTEM.SYS_EXPORT_SCHEMA_02;

Table dropped.

SQL> drop table SYSTEM.SYS_EXPORT_SCHEMA_03;

Table dropped.


SQL> select OWNER_NAME,JOB_NAME,OPERATION,JOB_MODE,STATE from dba_datapump_jobs order by STATE;

no rows selected




=========================
Crontab example format
=========================


# Minute   Hour   Day of Month       Month          Day of Week        Command    
# (0-59)  (0-23)     (1-31)    (1-12 or Jan-Dec)  (0-6 or Sun-Sat)                
    0        2          12             *                *            /usr/bin/find

===========================================
to findout server process id of a session
============================================

SET LINESIZE 100
COLUMN spid FORMAT A10
COLUMN username FORMAT A10
COLUMN program FORMAT A45

SELECT s.inst_id,
       s.sid,
       s.serial#,
       p.spid,
       s.username,
       s.program
FROM   gv$session s
       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id
WHERE  s.type != 'BACKGROUND';

   INST_ID        SID    SERIAL# SPID       USERNAME   PROGRAM
---------- ---------- ---------- ---------- ---------- ---------------------------------------------
         1         30         15 3859       TEST       sqlplus@oel5-11gr2.localdomain (TNS V1-V3)
         1         23        287 3834       SYS        sqlplus@oel5-11gr2.localdomain (TNS V1-V3)
         1         40        387 4663                  oracle@oel5-11gr2.localdomain (J000)
         1         38        125 4665                  oracle@oel5-11gr2.localdomain (J001)

==================================
RMAN Backup status at target side
===================================
col STARTTIME for a30
col ENDTIME for a30
select to_char(start_time,'DD-MON-YYYY HH24:MI:SS') StartTime, to_char(end_time,'DD-MON-YYYY HH24:MI:SS') EndTime,
input_type, status
from v$rman_backup_job_details
where start_time > sysdate-4 order by start_time;

STARTTIME          ENDTIME            INPUT_TYPE    STATUS
------------------ ------------------ ------------- -----------------------
28-SEP 08:00       28-SEP 08:06       ARCHIVELOG    COMPLETED
28-SEP 09:00       28-SEP 18:21       DB FULL       COMPLETED
28-SEP 11:00       28-SEP 11:02       ARCHIVELOG    COMPLETED
28-SEP 11:00       28-SEP 11:02       ARCHIVELOG    COMPLETED
28-SEP 20:00       28-SEP 20:02       ARCHIVELOG    COMPLETED
28-SEP 20:00       28-SEP 20:02       ARCHIVELOG    COMPLETED

==================================
RMAN Backup status at target side (metalink - Doc ID 2121092.1)
===================================

set lines 200
set operation format a10
--alter session set optimizer_mode=RULE;
alter session set nls_date_format = 'dd/mm/yyyy hh24:mi:ss';
select distinct p.tag,r.object_type,r.SESSION_RECID,r.START_TIME,r.END_TIME,(r.END_TIME-r.START_TIME)*24 "ET(Hr)",
r.OUTPUT_BYTES/1048576/1024 "SIZE (GB)",r.status,r.OUTPUT_DEVICE_TYPE,INPUT_BYTES_PER_SEC/1048576 "read (MB/sec)",OUTPUT_BYTES_PER_SEC/1048576 "output (MB/sec)"
from v$backup_piece p,v$rman_status r, v$rman_backup_job_details d
where p.RMAN_STATUS_RECID=r.RECID and p.RMAN_STATUS_STAMP=r.STAMP
and r.status like '%COMPLETED%' and r.OPERATION like '%BACKUP%'
and r.object_type like 'DB%'
and d.SESSION_RECID=r.SESSION_RECID;


set lines 200
set operation format a10
--alter session set optimizer_mode=RULE;
alter session set nls_date_format = 'dd/mm/yyyy hh24:mi:ss';
select distinct p.tag,r.object_type,r.SESSION_RECID,r.START_TIME,r.END_TIME,
r.OUTPUT_BYTES/1048576/1024 "SIZE (GB)",r.status,r.OUTPUT_DEVICE_TYPE
from v$backup_piece p,v$rman_status r, v$rman_backup_job_details d
where p.RMAN_STATUS_RECID=r.RECID and p.RMAN_STATUS_STAMP=r.STAMP
and r.status like '%COMPLETED%' and r.OPERATION like '%BACKUP%'
and r.object_type like 'DB%'
and d.SESSION_RECID=r.SESSION_RECID order by r.START_TIME desc;


Check resetlog files option is required or not
================================================

select open_resetlogs from v$database;

=============================
block corruption explained
==============================
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=336546677366708&id=336133.1&_afrWindowMode=0&_adf.ctrl-state=di2vitvsw_4

===========================================================================
Run the following sql query to find if the corrupted block is in free space
===========================================================================

Select * from dba_free_space where file_id=127  and 1921797 between block_id and block_id + blocks-1;

========================================================================================
Run the following sql query to find if the corrupted block is in free space or occupied
========================================================================================
set lines 200 pages 10000
col segment_name format a30

SELECT e.owner, e.segment_type, e.segment_name, e.partition_name, c.file#
, greatest(e.block_id, c.block#) corr_start_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1)
- greatest(e.block_id, c.block#) + 1 blocks_corrupted
, null description
FROM dba_extents e, v$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#
UNION
SELECT s.owner, s.segment_type, s.segment_name, s.partition_name, c.file#
, header_block corr_start_block#
, header_block corr_end_block#
, 1 blocks_corrupted
, 'Segment Header' description
FROM dba_segments s, v$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block# and c.block# + c.blocks - 1
UNION
SELECT null owner, null segment_type, null segment_name, null partition_name, c.file#
, greatest(f.block_id, c.block#) corr_start_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1)
- greatest(f.block_id, c.block#) + 1 blocks_corrupted
, 'Free Block' description
FROM dba_free_space f, v$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND f.block_id + f.blocks - 1 >= c.block#
ORDER BY file#, corr_start_block#;

========================================================
To check block corruptions via DBMS_REPAIR.CHECK_OBJECT
========================================================

SET SERVEROUTPUT ON
DECLARE num_corrupt INT;
BEGIN
num_corrupt := 0;
DBMS_REPAIR.CHECK_OBJECT (
SCHEMA_NAME => 'SCOTT',
OBJECT_NAME => 'DEPT',
REPAIR_TABLE_NAME => 'REPAIR_TABLE',
CORRUPT_COUNT => num_corrupt);
DBMS_OUTPUT.PUT_LINE('number corrupt: ' || TO_CHAR (num_corrupt));
END;
/

=================================
Mohit given queries - Block corruptions
==================================

SELECT SEGMENT_NAME, SEGMENT_TYPE, RELATIVE_FNO FROM DBA_EXTENTS WHERE FILE_ID =<FID> and <block_id> between BLOCK_ID AND BLOCK_ID + BLOCKS - 1;

SELECT SEGMENT_NAME, SEGMENT_TYPE, RELATIVE_FNO FROM DBA_EXTENTS WHERE FILE_ID = (select dbms_utility.data_block_address_file(176404107) from dual) AND (select dbms_utility.data_block_address_block(1176404107) from dual) between BLOCK_ID AND BLOCK_ID + BLOCKS - 1;


RMAN> RECOVER CORRUPTION LIST;


=============
System metrics
============

SELECT intsize_csec,metric_name,value, metric_unit FROM v$sysmetric order by 2;

INTSIZE_CSEC METRIC_NAME                                                           VALUE METRIC_UNIT
------------ ---------------------------------------------------------------- ---------- ----------------------------------------------------------------
        6012 Active Parallel Sessions                                                  0 Sessions
        6012 Active Serial Sessions                                                    1 Sessions
        1503 Average Active Sessions                                          .003124418 Active Sessions
        6012 Average Active Sessions                                          .004959681 Active Sessions
        6012 Average Synchronous Single-Block Read Latency                    .292857143 Milliseconds
        6012 Background CPU Usage Per Sec                                     .161319029 CentiSeconds Per Second
        6012 Background Checkpoints Per Sec                                            0 Check Points Per Second
        6012 Background Time Per Sec                                          .019981953 Active Sessions
        6012 Branch Node Splits Per Sec                                                0 Splits Per Second



SELECT name,class,value FROM v$sysstat ORDER BY class;





===============
AUDITING
===============

https://ramkedem.com/en/oracle-auditing-examples/ (Auditing full details)

Count of Connects by User in the Last Week
-------------------------------------------------------
SELECT das.username,
       COUNT(*) logonCount
  FROM sys.dba_audit_session das
 WHERE das.timeStamp > SYSDATE-7
   AND das.returnCode = 0
 GROUP BY das.username;

Number of Minutes Connected By User in the Last Week
-------------------------------------------------------------------
SELECT das.username,
       ROUND(SUM((NVL(das.logoff_time,SYSDATE)-das.timestamp)*1440)) connectMins
  FROM sys.dba_audit_session das
 WHERE das.timeStamp > SYSDATE-7
   AND das.returnCode = 0
 GROUP BY das.username;

Unsuccessful Logon Attempts in the Last Week
----------------------------------------------------------
SELECT das.username,
       das.os_username,
       das.terminal,
       TO_CHAR(das.timeStamp,'DD Mon YYYY HH24:MI') timestamp,
       das.returnCode
  FROM sys.dba_audit_session das
 WHERE das.timeStamp > SYSDATE-7
   AND das.returnCode != 0;

Connections Made Out Of Working Hours in the Last Week
--------------------------------------------------------------------------
SELECT das.username,
       TO_CHAR(das.timestamp,'DD Mon YYYY HH24:MI:SS')   logontime,
       TO_CHAR(das.logoff_time,'DD Mon YYYY HH24:MI:SS') logofftime
  FROM sys.dba_audit_session das
 WHERE das.timeStamp > SYSDATE-7
   AND das.returnCode = 0
   AND NOT (    TO_NUMBER(TO_CHAR(das.timestamp,'D')) < 6 
            AND TO_NUMBER(TO_CHAR(das.timestamp,'HH24MI')) BETWEEN 800 AND 1800 )
 ORDER BY das.username;



PGA usage, top consumers
==================
select round(p.pga_alloc_mem/1024/1024) "pga_alloc_MiB",round(p.pga_used_mem/1024/1024) "pga_used_MiB", 
p.spid "OS_pid", s.sid, s.serial#, s.username, s.status, s.client_info, s.osuser, s.machine, s.terminal, s.program, s.module,s.sql_id
from gv$process p, gv$session s where p.addr=s.paddr
order by p.pga_alloc_mem desc;

UNDO usage, top consumers
====================
select round(t.used_ublk*(select block_size from dba_tablespaces where tablespace_name=(select value from v$parameter where name = 'undo_tablespace'))/1024/1024) "undo_used_MiB",
t.used_ublk used_blocks,
t.START_DATE trn_started,
s.sid, s.serial#, s.username, s.status,s.osuser, s.machine, s.terminal, s.program, s.module,s.sql_id
from V$TRANSACTION t, v$session S 
where t.SES_ADDR=s.saddr 
order by used_ublk desc;

TEMP usage, top consumers
===================
select t.tablespace, t.blocks,
round((t.blocks * ts.block_size)/1024/1024) "Size_MiB", t.segtype,
s.sid, s.serial#, s.username, s.status,s.osuser, s.machine, s.terminal, s.program, s.module,s.sql_id
from v$session s, v$tempseg_usage t, dba_tablespaces ts
where t.tablespace=ts.tablespace_name and s.saddr = t.session_addr
order by t.blocks desc;



Check for non-successful connection attempts in listener.log
======================================= 
https://martincarstenbach.wordpress.com/2010/02/09/check-for-non-successful-connection-attemps-in-listener-log/

=========================
If procedures exist inside a PACKAGE ( http://stackoverflow.com/questions/28343972/unable-to-find-procedure-in-dba-procedures-view )
=========================

SQL> SELECT object_name, procedure_name, object_type from user_procedures where object_name='ORP_MTH_AGG_PKG' order by procedure_name;

OBJECT_NAME                                        PROCEDURE_NAME                 OBJECT_TYPE
-------------------------------------------------- ------------------------------ -------------------
ORP_MTH_AGG_PKG                                    AGGREGATE_DAILY_DATA_PRC       PACKAGE
ORP_MTH_AGG_PKG                                    AGGREGATE_MONTHLY_DATA_RLI_PRC PACKAGE
ORP_MTH_AGG_PKG                                    AGGREGATE_PRODUCT_VER_MTH_PRC  PACKAGE
ORP_MTH_AGG_PKG                                    AGGREGATE_SUMMARY_MTH_DATA_PRC PACKAGE
ORP_MTH_AGG_PKG                                    CREATE_METERED_TN_FACT_PRC     PACKAGE
ORP_MTH_AGG_PKG                                    FILTER_CALL_CONNECT_EVENTS_PRC PACKAGE
ORP_MTH_AGG_PKG                                    FILTER_CALL_CONNECT_RUN_PRC    PACKAGE
ORP_MTH_AGG_PKG                                    GET_TABLE_DEGREE_CONFIG_PRC    PACKAGE
ORP_MTH_AGG_PKG                                    POFE_ADV_MTH_AGG_PRC           PACKAGE
ORP_MTH_AGG_PKG                                    POFE_MONTHLY_AGGREGATE_PRC     PACKAGE
ORP_MTH_AGG_PKG                                    PRE_AGGREGATE_DAILY_DATA_PRC   PACKAGE
ORP_MTH_AGG_PKG                                                                   PACKAGE


To know if a table is waiting for sometning (in a query of multiple tables)
================================================
select OWNER,TABLE_NAME,NUM_ROWS,BLOCKS,AVG_ROW_LEN,CHAIN_CNT,LAST_ANALYZED,PARTITIONED from dba_tables where table_name in ('DAS_OUT','DAS_PB_ITEM_TEXT','DAS_PB_ITEM');

========================
Fragmentation check for tablespaces
========================
set lines 200 pages 300
SELECT
 tablespace_name, 
 count(*) free_extents_MB,
 decode(round((max(bytes)/1024/1024),2),
 null,0,
 round((max(bytes)/1024/1024),2)) largest_extent_MB,
 nvl(round(sqrt(max(blocks)/sum(blocks))*(100/sqrt(sqrt(count(blocks)) )),2),0) "1->More frags : 100-> No frags"
 FROM
 sys.dba_free_space 
 group by 
 tablespace_name
 order by 2 desc, 1;

#########################################
DB_LINKS check in a database Start
###########################################

REM Validate Database Links
REM Private links under connected user and Public links
REM
REM Biju Thomas - 29-Oct-2013
REM
set serveroutput on size 99999
set pages 0 lines 300 trims on
col spoolfile new_value spoolfname
select '/tmp/checklinks_'||user ||'_'||
       substr(global_name, 1, instr(global_name,'.')-1)||
       '.txt' spoolfile from global_name;
spool '&spoolfname'
declare
 --
 -- Get list of links the user has access to
 cursor mylinks is select db_link, owner, created, host, username
                   from all_db_links;
 --
 -- Identify other links in the DB for information
 cursor otherlinks is select db_link, owner
                      from dba_db_links
                      minus
                      select db_link, owner
                      from all_db_links;
 dbname varchar2 (200);
 currentuser varchar2 (30);
 linkno number := 0;
begin

 -- Current database and connected user
 select name, user into dbname, currentuser from v$database;
 dbms_output.put_line('Verifying Database Links '||currentuser||'@'||dbname);
 dbms_output.put_line('========================================================');
 --
 for linkcur in mylinks loop
  linkno := linkno + 1;
  dbms_output.put_line('Checking Link: ' || linkno) ;
  dbms_output.put_line('Link Name    : ' || linkcur.db_link) ;
  dbms_output.put_line('Link Owner   : ' || linkcur.owner) ;
  dbms_output.put_line('Connect User : ' || linkcur.username) ;
  dbms_output.put_line('Connect To   : ' || linkcur.host) ;
  begin
    --
    -- Connect to the link to validate, get global name of destination database
    execute immediate 'select global_name from global_name@"'||linkcur.db_link||'"' into dbname;
    dbms_output.put_line('$$$$ DB LINK SUCCESSFULLY connected to '||dbname);
    --
    -- end the transaction and explicitly close the db link
    commit;
    execute immediate 'alter session close database link "'||linkcur.db_link||'"';
  exception
    --
    -- DB Link connection failed, show error message
    when others then
    dbms_output.put_line('@@@@ DB LINK FAILED  @@@@');
    dbms_output.put_line('Error: '||sqlerrm);
  end;
  dbms_output.put_line('---------------------------------------');
  dbms_output.put_line(' ');
 end loop;
 dbms_output.put_line('Tests Completed.');
 --
 -- List other Links in the DB
 dbms_output.put_line('Other Private Links in the Database');
 dbms_output.put_line('Connect as respective owner to validate these.');
 dbms_output.put_line('----------------------------------------------');
 for olinks in otherlinks loop
   dbms_output.put_line(olinks.owner ||' :: '||olinks.db_link);
 end loop;
end;
/

spool
spool off
set pages 99 lines 80 trims off

#########################################
DB_LINKS check in a database END
###########################################

########################################################
START --> Script to monitor RMAN Backup and Restore Operations (Doc ID 1487262.1)
########################################################

REM -------------------------------
REM Script to monitor rman backup/restore operations
REM To run from sqlplus:   @monitor '<dd-mon-rr hh24:mi:ss>' 
REM Example:  
--SQL>spool monitor.out
--SQL>@monitor '06-aug-12 16:38:03'
REM where <date> is the start time of your rman backup or restore job
REM Run monitor script periodically to confirm rman is progessing
REM -------------------------------

alter session set nls_date_format='dd-mon-rr hh24:mi:ss';
set lines 1500
set pages 100
col CLI_INFO format a10
col spid format a5
col ch format a20
col seconds format 999999.99
col filename format a65
col bfc  format 9
col "% Complete" format 999.99
col event format a40
set numwidth 10

select sysdate from dual;

REM gv$session_longops (channel level)

prompt
prompt Channel progress - gv$session_longops:
prompt
select s.inst_id, o.sid, CLIENT_INFO ch, context, sofar, totalwork,
                    round(sofar/totalwork*100,2) "% Complete"
     FROM gv$session_longops o, gv$session s
     WHERE opname LIKE 'RMAN%'
     AND opname NOT LIKE '%aggregate%'
     AND o.sid=s.sid
     AND totalwork != 0
     AND sofar <> totalwork;

REM Check wait events (RMAN sessions) - this is for CURRENT waits only
REM use the following for 11G+
prompt
prompt Session progess - CURRENT wait events and time in wait so far:
prompt
select inst_id, sid, CLIENT_INFO ch, seq#, event, state, wait_time_micro/1000000 seconds
from gv$session where program like '%rman%' and
wait_time = 0 and
not action is null;

REM use the following for 10G
--select  inst_id, sid, CLIENT_INFO ch, seq#, event, state, seconds_in_wait secs
--from gv$session where program like '%rman%' and
--wait_time = 0 and
--not action is null;

REM gv$backup_async_io
prompt
prompt Disk (file and backuppiece) progress - includes tape backuppiece 
prompt if backup_tape_io_slaves=TRUE:
prompt
select s.inst_id, a.sid, CLIENT_INFO Ch, a.STATUS,
open_time, round(BYTES/1024/1024,2) "SOFAR Mb" , round(total_bytes/1024/1024,2)
TotMb, io_count,
round(BYTES/TOTAL_BYTES*100,2) "% Complete" , a.type, filename
from gv$backup_async_io a,  gv$session s
where not a.STATUS in ('UNKNOWN')
and a.sid=s.sid and open_time > to_date('&1', 'dd-mon-rr hh24:mi:ss') order by 2,7;

REM gv$backup_sync_io
prompt
prompt Tape backuppiece progress (only if backup_tape_io_slaves=FALSE):
prompt
select s.inst_id, a.sid, CLIENT_INFO Ch, filename, a.type, a.status, buffer_size bsz, buffer_count bfc,
open_time open, io_count
from gv$backup_sync_io a, gv$session s
where
a.sid=s.sid and
open_time > to_date('&1', 'dd-mon-rr hh24:mi:ss') ;
REM -------------------------------

########################################################
END --> Script to monitor RMAN Backup and Restore Operations (Doc ID 1487262.1)
########################################################

####################################################################
START - To find out object dependency -- Script:SQL DIAG- Determining Dependency Information (Doc ID 62435.1)
#####################################################################

REM depends.sql     Try to determine what objects an objects depends on
REM            within the database. 
REM 
REM Usage:          Connect to SQL*Plus as a DBA user and run this script.
REM                 When prompted for 'OWNER' enter the owner or a pattern
REM                 Eg: sco%
REM                 When prompted for the 'OBJECT' enter its name or a pattern.
REM                 The relevant objects should be listed. 
REM                 Select the object ID of the required object to check. 
REM
REM                 A immediate dependency chart should be shown.
REM
REM 
set echo off
set feedback off
set ver off
set pages 10000
column Owner format "A25"
column Obj#  format "99999999"
column Object format "A42"
rem
ACCEPT OWN   CHAR PROMPT "Enter OWNER pattern: "
ACCEPT NAM   CHAR PROMPT "Enter OBJECT NAME pattern: "
prompt
prompt "Objects matching &&OWN..&&NAM"
prompt "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
select o.obj# "Obj#",
       decode(o.linkname, null, 
        u.name||'.'||o.name,
        o.remoteowner||'.'||o.name||'@'||o.linkname) "Object",
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
            4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
            7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
            10, '*Not Exist*',
            11, 'PKG BODY', 12, 'TRIGGER', 
            13, 'TYPE', 14,'TYPE BODY',
            19,'TABLE PARTITION', 20,'INDEX PARTITION',
            21,'LOB',22,'LIBRARY',
            23,'DIRECTORY', 'UNDEFINED') "Type",
       decode(o.status,0,'N/A',1,'VALID', 'INVALID') "Status"
  from sys.obj$ o, sys.user$ u 
 where owner#=user# 
   and u.name like upper('&&OWN') and o.name like upper('&&NAM')
;
prompt
ACCEPT OBJID CHAR PROMPT "Enter Object ID required: "
prompt
prompt
prompt "Object &&OBJID is:"
prompt "~~~~~~~~~~~~~~~~~~~"
select o.obj# "Obj#",
       decode(o.linkname, null, 
        u.name||'.'||o.name,
        o.remoteowner||'.'||o.name||'@'||o.linkname) "Object",
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
            4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
            7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
            10, '*Not Exist*',
            11, 'PKG BODY', 12, 'TRIGGER', 
            13, 'TYPE', 14,'TYPE BODY',
            19,'TABLE PARTITION', 20,'INDEX PARTITION',
            21,'LOB',22,'LIBRARY',
            23,'DIRECTORY', 'UNDEFINED') "Type",
       decode(o.status,0,'N/A',1,'VALID', 'INVALID') "Status",
       substr(to_char(stime,'DD-MON-YYYY HH24:MI:SS'),1,20) "S-Time"
  from sys.obj$ o, sys.user$ u 
 where owner#=user# and o.obj#='&&OBJID';

prompt 
prompt "**** &&NAM depends on below objects*****"
prompt "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

select o.obj# "Obj#", 
       decode(o.linkname, null, 
        nvl(u.name,'Unknown')||'.'||nvl(o.name,'Dropped?'),
        o.remoteowner||'.'||nvl(o.name,'Dropped?')||'@'||o.linkname) "Object",
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
            4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
            7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
            10, '*Not Exist*',
            11, 'PKG BODY', 12, 'TRIGGER', 
            13, 'TYPE', 14,'TYPE BODY',
            19,'TABLE PARTITION', 20,'INDEX PARTITION',
            21,'LOB',22,'LIBRARY',
            23,'DIRECTORY', 'UNDEFINED') "Type",
        decode(sign(stime-P_TIMESTAMP),
                      1,'*NEWER*',-1,'*?OLDER?*',null,'-','-SAME-') "TimeStamp",
  decode(o.status,0,'N/A',1,'VALID','INVALID') "Status"
  from sys.dependency$ d,  sys.obj$ o, sys.user$ u
 where P_OBJ#=obj#(+) and o.owner#=u.user#(+) and D_OBJ#='&&OBJID';

prompt
prompt "Below objects depends on &&NAM"
prompt "~~~~~~~~~~~~~~~~~~~~~~~~"

select o.obj# "Obj#", 
       decode(o.linkname, null, 
        nvl(u.name,'Unknown')||'.'||nvl(o.name,'Dropped?'),
        o.remoteowner||'.'||nvl(o.name,'Dropped?')||'@'||o.linkname) "Object",
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
            4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
            7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
            10, '*Not Exist*',
            11, 'PKG BODY', 12, 'TRIGGER', 
            13, 'TYPE', 14,'TYPE BODY',
            19,'TABLE PARTITION', 20,'INDEX PARTITION',
            21,'LOB',22,'LIBRARY',
            23,'DIRECTORY', 'UNDEFINED') "Type",
        decode(sign(stime-D_TIMESTAMP),
                      1,'*NEWER*',-1,'*?OLDER?*',null,'-','-SAME-') "TimeStamp",
  decode(o.status,0,'N/A',1,'VALID','INVALID') "Status"
  from sys.dependency$ d,  sys.obj$ o, sys.user$ u
 where D_OBJ#=obj#(+) and o.owner#=u.user#(+) and P_OBJ#='&&OBJID';

####################################################################
END - To find out object dependency -- Script:SQL DIAG- Determining Dependency Information 
#####################################################################

#####################################################################
START - IF: How to Find SQLs Causing ORA-1000 (open cursors issue) (Doc ID 2014381.1)
#####################################################################

OPEN_CURSORS initialization parameter sets the maximum number of cursors each session can have open. For example, if OPEN_CURSORS value is set to 1000, then each session can have up to 1000 cursors open at one time.

OPEN_CURSORS can be maxed out in a database if there is any cursor leakage from application code and in some cases, from Oracle code which will be fixed using an Oracle patch.

The following steps help to find out the sessions/SQLs that are creating excessive cursors.

1. Find out sessions which have high number of cursors open. Below query can be used to order sessions by their open cursor count:

SELECT s.sid, s.serial#, s.username, a.value "OPEN CURSOR COUNT" 
FROM v$sesstat a, v$statname b, v$session s 
WHERE a.statistic# = b.statistic# 
AND s.sid=a.sid AND b.name = 'opened cursors current' 
AND s.username IS NOT NULL
ORDER BY a.value desc;

2. Find out the sqls that are creating these open cursors for each session. 
Substitute the top SIDs obtained from above output in below query to obtain the sqls responsible for high open cursor count:

SELECT sid ,sql_text, user_name, count(*) as "OPEN CURSORS" 
FROM v$open_cursor 
WHERE sid IN ($SID) 
GROUP BY sid ,sql_text, user_name;

3. If issue is sporadic, and if ORA-1000 error is being thrown repeatedly, then set an errorstack for ORA-1000 error to capture the cursor details.

SQL> alter system set events '1000 trace name errorstack level 3';
To unset after trace file is generated:
SQL> alter system set events '1000 trace name errorstack off';

#############################################################
END - IF: How to Find SQLs Causing ORA-1000 (open cursors issue) 
#############################################################

================================================
SQL Query start time and end time of perticular SQL ID
================================================

alter session set nls_date_format='YYYY/MM/DD HH24:MI:SS';
alter session set nls_timestamp_format='YYYY/MM/DD HH24:MI:SS';
 
select sql_id,
      starting_time,
      end_time,
 ((EXTRACT(HOUR FROM run_time) * 3600 + EXTRACT(MINUTE FROM run_time) * 60 + EXTRACT(SECOND FROM run_time)))/(60*60) run_time_hours,
      READ_IO_BYTES,
      PGA_ALLOCATED PGA_ALLOCATED_BYTES,
      TEMP_ALLOCATED TEMP_ALLOCATED_BYTES
from  (
select
       sql_id,
       max(sample_time - sql_exec_start) run_time,
       max(sample_time) end_time,
       sql_exec_start starting_time,
       sum(DELTA_READ_IO_BYTES) READ_IO_BYTES,
       sum(DELTA_PGA) PGA_ALLOCATED,
       sum(DELTA_TEMP) TEMP_ALLOCATED
       from
       (
       select sql_id,
       sample_time,
       sql_exec_start,
       DELTA_READ_IO_BYTES,
       sql_exec_id,
       greatest(PGA_ALLOCATED - first_value(PGA_ALLOCATED) over (partition by sql_id,sql_exec_id order by sample_time rows 1 preceding),0) DELTA_PGA,
       greatest(TEMP_SPACE_ALLOCATED - first_value(TEMP_SPACE_ALLOCATED) over (partition by sql_id,sql_exec_id order by sample_time rows 1 preceding),0) DELTA_TEMP
       from
       dba_hist_active_sess_history
       where
       sample_time >= to_date ('2016/09/20 07:00:00','YYYY/MM/DD HH24:MI:SS')
       and sample_time < to_date ('2016/09/20 14:00:00','YYYY/MM/DD HH24:MI:SS')
       and sql_exec_start is not null
       and IS_SQLID_CURRENT='Y'
       )
group by sql_id,SQL_EXEC_ID,sql_exec_start
order by sql_id
)
where sql_id = '&enter_SQLID' order by run_time_hours desc;

Output
=====

SQL_ID        STARTING_TIME       END_TIME            RUN_TIME_SEC READ_IO_BYTES PGA_ALLOCATED_BYTES TEMP_ALLOCATED_BYTES
------------- ------------------- ------------------- ------------ ------------- ------------------- --------------------
btvk5dzpdmadh 2013/04/16 00:05:01 2013/04/16 03:09:56    11095.559    2.0417E+10           240123904           2642411520
btvk5dzpdmadh 2013/04/16 00:05:01 2013/04/16 03:09:56    11095.559    2.2207E+10           181993472           2233466880
btvk5dzpdmadh 2013/04/16 00:05:01 2013/04/16 03:09:56    11095.559    2.4342E+10           192610304           2453667840
btvk5dzpdmadh 2013/04/16 00:13:43 2013/04/16 03:09:56    10573.559    1.3095E+10           212074496           1142947840
btvk5dzpdmadh 2013/04/16 00:05:01 2013/04/16 02:10:10     7509.398    1.9374E+10           200540160           2076180480

==============================================================================





======================================================================
Database patch set details on one server of serveral homes
How to gather OPatch inventory for all RAC Oracle Homes, regardless of role separation. (Doc ID 1922360.1)
=======================================================================

#!/bin/bash
# File: ListAllOraHomesInv.sh  (Author: Bob Clare, Oracle Support Engineer)
# Created: 21-Mar-15		Modified: 19-Sep-16
# Checks Oracle Central/Global Inventory & Local Registry (along w/OraTab & 
# OraGCHomeList files) to list all active Oracle Homes & Instances, then finds 
# each Home's Owner and runs OPatch from each Home as the Owner, filtering for 
# just the key info.  LFD is Loc[ation] File Directory, OCI is Oracle Central 
# Inventory, OLR is Oracle Local Registry, rest should be self-explanatory!  
export PATH=/sbin:/bin:/usr/sbin:/usr/bin ; Script=$(basename $0)
(($EUID)) && { echo "Script $Script must be run as root!" ; exit 1 ; }
# Above check for root uses a "bash-ism", but remainder is also ksh-compliant. 
{ case $(uname) in SunOS ) OCILFD=/var/opt/oracle ; OLRLFD=$OCILFD ;; * )
OCILFD=/etc ; OLRLFD=$OCILFD/oracle ;; esac ; OCILOC=$OCILFD/oraInst.loc
OEMHL=$OCILFD/oragchomelist ; OLRLOC=$OLRLFD/olr.loc ; ORATAB=$OCILFD/oratab
DL=$(printf '%80s' | tr ' ' '=') ; echo $DL ; [ -r $ORATAB ] && { echo \
"Active Oracle instances (from $ORATAB):" ; cut -d# -f1 $ORATAB | cut -d: \
-f-3 -s | sort | cat -n ; echo $DL ; echo "Oracle Homes (of Active Oracle \
instances from $ORATAB):" ; cut -d# -f1 $ORATAB | cut -d: -f2 -s | sort -u | \
cat -n ; echo $DL ; } ; [ -r $OCILOC ] && { echo "Oracle Central Inventory \
Location Pointer: $OCILOC" ; OCIDIR=$(grep _loc= $OCILOC | cut -d= -f2)
[ -d $OCIDIR ] && { echo "Oracle Central Inventory Directory: $OCIDIR"
OCIXML=$OCIDIR/ContentsXML/inventory.xml ; [ -r $OCIXML ] && { echo "Oracle \
Homes in Central Inventory, except EM plugins" ; echo "(from $OCIXML):"
egrep -v 'REMOVED|sbin|plugins' $OCIXML | grep "HOME NAME=" | cut -d\" -f2,4 \
| tr '"' '=' | sort ; echo $DL ; } ; } ; } ; [ -r $OLRLOC ] && { echo "Oracle \
Local Registry Location Pointer: $OLRLOC" ; CRS_HOME=$(grep home= $OLRLOC | \
cut -d= -f2) ; [ -d $CRS_HOME ] && { echo "CRS Home: $CRS_HOME" ; CRSCFG=\
$CRS_HOME/crs/install/crsconfig_params ; [ -r $CRSCFG ] && { CRS_OWNER=\
$(grep OWNER $CRSCFG | cut -d= -f2) ; [ -n "$CRS_OWNER" ] && { echo "CRS Home \
Owner: $CRS_OWNER" ; OPATCH=$CRS_HOME/OPatch/opatch ; [ -x $OPATCH ] && su \
$CRS_OWNER -c "$OPATCH lsinv -oh $CRS_HOME -all | awk '/^List of Oracle Homes:\
$/,/^$/ { print }'" | egrep -v 'sbin|plugins' ; echo $DL ; } ; } ; } ; }
[ -r $ORATAB ] && { for OH in $(cut -d# -f1 $ORATAB | cut -d: -f2 -s | sort -u)
do OH_OWNER=$(ls -dl $OH | awk '{ print $3 }') ; [ "$OH_OWNER" == "root" ] && \
OH_OWNER=$CRS_OWNER ; ls -dl $OH ; OPATCH=$OH/OPatch/opatch ; [ -x $OPATCH ] \
&& su $OH_OWNER -c "$OPATCH lsinv -oh $OH | egrep '^Ce|^I|^O|^P|^T|from|node'"
echo $DL ; done ; } ; [ -r $OEMHL ] && { echo "Oracle Enterprise Manager OMS \
and/or Agent Homes in $OEMHL :" ; cat -bs $OEMHL ; echo $DL ; { for OH in $(\
cut -d: -f1 $OEMHL | sort -u) ; do [ -d $OH ] && { ls -dl $OH ; OH_OWNER=$(ls \
-dl $OH | awk '{ print $3 }') ; OPATCH=$OH/OPatch/opatch ; [ -x $OPATCH ] && \
su $OH_OWNER -c "$OPATCH lsinv -oh $OH | egrep '^Ce|^E|^I|^O|^P|^T|from|node'"
echo $DL ; } ; done ; } ; } ; } | tee /tmp/OPinv.log
# EOF

=====================================================================

Script to monitor PX limits from Resource Manager for active sessions (Doc ID 240877.1)
=====================================================================

It shows the parallel degree limit from resource manager for all connect users. Degrees of 0 or 1 mean that the query is running in serial.

select s.SID, s.SERIAL#, s.username ,rpd.plan,
       s.RESOURCE_CONSUMER_GROUP,
       rpd.PARALLEL_DEGREE_LIMIT_P1 
from   v$session s, 
       DBA_RSRC_CONSUMER_GROUPS rcg,
       DBA_RSRC_PLAN_DIRECTIVES rpd ,
       V$RSRC_CONSUMER_GROUP vcg
where  s.RESOURCE_CONSUMER_GROUP is not null
   and rcg.CONSUMER_GROUP = s.RESOURCE_CONSUMER_GROUP
   and rcg.status = 'ACTIVE'
   and rpd.GROUP_OR_SUBPLAN = rcg.CONSUMER_GROUP
   and rpd.status = 'ACTIVE'
   and vcg.name = s.RESOURCE_CONSUMER_GROUP;


Example output

 SID SERIAL#  USERNAME         PLAN          RESOURCE_CONSUMER_GROUP PARALLEL_DEGREE_LIMIT_P1
 --- ------- ----------- ------------------ ------------------------ ------------------------ 
9       117        HR         MAILDB_PLAN    MAIL_MAINTENANCE_GROUP              0 

The user HR has a Parallel Degree Limit 0, this means all his queries are running serial.


dynamic script to move all tables/indexes/LOBS
=================================

http://www.jotaurdaneta.com/databases/how-to-move-all-objects-in-a-schema-to-a-different-tablespace/


Check who is using more PGA
===================== 

column event format a30
column username format a10
column osuser format a10
column program format a23
column spid format a7
column PGA_MB format 999,990.90
column PGA_MAX_MB format 999,990.90

SELECT s.username, p.spid, p.pid, s.sid, s.serial#, s.status, 
round(p.pga_alloc_mem/1048576,2) PGA_MB,
round(p.pga_max_mem/1048576,2) pga_max_mB,
s.username, s.osuser, s.program, s.sql_id, s.event
FROM v$process p,v$session s
WHERE s.paddr ( + ) = p.addr
AND sid != (select sid from v$mystat where rownum =1 )
AND s.type='USER'
Order by p.pga_alloc_mem desc; 



Database GROWTH on quartyearly basis
===========================

select to_char(creation_time, 'MM-RRRR') "Month", sum(bytes)/1024/1024/1024 "Growth in GB" from sys.v_$datafile where to_char(creation_time,'RRRR')='2017' group by to_char(creation_time, 'MM-RRRR') order by  to_char(creation_time, 'MM-RRRR');


select to_char(CREATION_TIME,'RRRR') year, to_char(CREATION_TIME,'MM') month, round(sum(bytes)/1024/1024/1024) GB from v$datafile group by  to_char(CREATION_TIME,'RRRR'),   to_char(CREATION_TIME,'MM') order by   1, 2; 


RMAN BACKUP Status
==================== 
select to_char(START_TIME,'DD-MON-YYYY HH24:MI:SS') START_TIMESTAMP ,to_char(END_TIME,'DD-MON-YYYY HH24:MI:SS') END_TIMESTAMP,STATUS,round(INPUT_BYTES/1024/1024/1024,2) DB_SIZE,round(OUTPUT_BYTES/1024/1024/1024,2) BACKUP_SIZE,INPUT_TYPE,COMPRESSION_RATIO from v$RMAN_BACKUP_JOB_DETAILS where START_TIME > sysdate-4 order by START_TIME asc;

Granting DEBUG privilage
========================= 
grant DEBUG CONNECT SESSION to  <user_name> ;
grant DEBUG ANY PROCEDURE to <user_name>  ;
grant debug on < procedure name> to <username>;

to see the privilage,

select GRANTEE,PRIVILEGE from dba_sys_privs where grantee='username';

GRANTEE   PRIVILEGE
--------- ----------------------------------------
SMARTNLP1 DEBUG CONNECT SESSION

Complete dba_tab_privs of a perticular schema and all the database objects
============================================================================
select
  owner,
  table_name,
  grantee,
  grantor,
  max(case when privilege = 'SELECT'            then 'sel' end) sel,
  max(case when privilege = 'INSERT'            then 'ins' end) ins,
  max(case when privilege = 'UPDATE'            then 'upd' end) upd,
  max(case when privilege = 'DELETE'            then 'del' end) del,
  max(case when privilege = 'ALTER'             then 'alt' end) alt,
  max(case when privilege = 'READ'              then 'rea' end) rea,
  max(case when privilege = 'QUERY REWRITE'     then 'qrr' end) qrr,
  max(case when privilege = 'DEBUG'             then 'dbg' end) dbg,
  max(case when privilege = 'ON COMMIT REFRESH' then 'ocr' end) ocr,
  max(case when privilege = 'FLASHBACK'         then 'flb' end) flb
from
  dba_tab_privs
where
  owner ='&ENTER_OWNER'
group by
  owner,
  table_name,
  grantee,
  grantor
order by
  owner,
  table_name,
  grantee,
  grantor;




select
  owner,
  table_name,
  grantee,
  grantor,
  max(case when privilege = 'SELECT'            then 'sel' end) sel,
  max(case when privilege = 'INSERT'            then 'ins' end) ins,
  max(case when privilege = 'UPDATE'            then 'upd' end) upd,
  max(case when privilege = 'DELETE'            then 'del' end) del,
  max(case when privilege = 'ALTER'             then 'alt' end) alt,
  max(case when privilege = 'READ'              then 'rea' end) rea,
  max(case when privilege = 'QUERY REWRITE'     then 'qrr' end) qrr,
  max(case when privilege = 'DEBUG'             then 'dbg' end) dbg,
  max(case when privilege = 'ON COMMIT REFRESH' then 'ocr' end) ocr,
  max(case when privilege = 'FLASHBACK'         then 'flb' end) flb
from
  dba_tab_privs
where
  owner not in ('SYS', 'SYSTEM', 'APPQOSSYS', 'DBSNMP', 'GSMADMIN_INTERNAL', 'XDB', 'WMSYS','ORDSYS','MDSYS',CTXSYS','DVSYS')
group by
  owner,
  table_name,
  grantee,
  grantor
order by
  owner,
  table_name,
  grantee,
  grantor;


If we want to access a table with database link (DB LINK) and materialized view (MAT VIEW) and table have where condition
===========================================================================================================================

  CREATE MATERIALIZED VIEW "REPTUSER"."MV_SAP_RSP_1" ("REC_ID", "EFF_DT", "KUNNR
", "MATNR", "AUT_SENT_DTTM", "AUT_SENT_BY", "RSP", "PI_FLAG", "PI_UPD_DTTM", "AP
PLY_FLAG", "CREATED_DT")
  REFRESH COMPLETE ON DEMAND START WITH sysdate+0 NEXT SYSDATE+1/48
  AS SELECT * FROM SAP_RSP@REPT_TO_RSP WHERE EFF_DT>SYSDATE-10;

Auto refresh of MAT_VIWE with COMPLETE
=========================================

CREATE MATERIALIZED VIEW "REPTUSER"."MV_SAP_RSP_1" ("REC_ID", "EFF_DT", "KUNNR","MATNR", "AUT_SENT_DTTM", "AUT_SENT_BY", "RSP", "PI_FLAG", "PI_UPD_DTTM", "APPLY_FLAG", "CREATED_DT") refresh complete start with (sysdate) next (sysdate+1/48) with rowid AS select * from sap_rsp@REPT_TO_RSP where eff_dt>sysdate-10;

CREATE MATERIALIZED VIEW "REPTUSER"."MV_SAP_RSP_2" refresh complete start with (sysdate) next (sysdate+10/(24*60)) with rowid AS select * from sap_rsp@REPT_TO_RSP where eff_dt>sysdate-10;


CREATE MATERIALIZED VIEW "REPTUSER"."MV_SAP_RSP_2"
BUILD DEFFERED
REFRESH FAST
START WITH SYSDATE NEXT SYSDATE + 1/48
WITH PRIMARY KEY
AS SELECT * FROM SAP_RSP@REPT_TO_RSP WHERE EFF_DT>SYSDATE-10;

Auto refresh of MAT_VIWE with FAST. This is only works with "select * from emp". If you give where condition, this fast refresh wont work
=====================================================================================================================================
mat view log creation
======================= 
create materialized view log on SMARTRSP.sap_rsp with rowid; (on the base table)

dba_mview_logs

mat view creation
===================
CREATE MATERIALIZED VIEW MV_SAP_RSP
  ORGANIZATION HEAP PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "RPTTBS"
  BUILD IMMEDIATE
  USING INDEX
  REFRESH FAST ON DEMAND START WITH sysdate+0 NEXT SYSDATE + 1/48
  WITH ROWID USING DEFAULT LOCAL ROLLBACK SEGMENT
  USING ENFORCED CONSTRAINTS DISABLE QUERY REWRITE
  AS SELECT * FROM SAP_RSP@REPT_TO_RSP;
  
  FRA usage
  ========== 
  SELECT NAME,SPACE_LIMIT/1024/1024 TOTAL_MB,(SPACE_LIMIT - SPACE_USED + SPACE_RECLAIMABLE)/1024/1024 AS FREE_MB,ROUND((SPACE_USED - SPACE_RECLAIMABLE)/SPACE_LIMIT * 100, 1) AS "%FULL" FROM V$RECOVERY_FILE_DEST;
  
  
  
CREATE MATERIALIZED VIEW REPTUSER.VTCMCUST ORGANIZATION HEAP PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
NOCOMPRESS LOGGING
STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
TABLESPACE "RPTTBS"
BUILD IMMEDIATE
USING INDEX
REFRESH FAST ON DEMAND START WITH sysdate+0 NEXT SYSDATE + 1/48
WITH ROWID USING DEFAULT LOCAL ROLLBACK SEGMENT
USING ENFORCED CONSTRAINTS DISABLE QUERY REWRITE AS SELECT * FROM VTCMCUST@REPT_TO_NLP;






 CREATE MATERIALIZED VIEW "REPTUSER"."VTSMLKP" ("LKPTYPE", "LKPVALUE", "LKPDESC", "SORTORDER", "STATUS", "CRTBY", "CRTDATE", "CRTIP")
  ORGANIZATION HEAP PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "RPTTBS"   NO INMEMORY
  BUILD IMMEDIATE
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "RPTTBS"
  REFRESH FAST ON DEMAND START WITH sysdate+0 NEXT SYSDATE + 1/48
  WITH PRIMARY KEY USING DEFAULT LOCAL ROLLBACK SEGMENT
  USING ENFORCED CONSTRAINTS DISABLE QUERY REWRITE
  AS SELECT * FROM VTSMLKP@REPT_TO_NLP;
  
  
exec dbms_mview.refresh('TDS_GRPVIEW_ACCPDT_NLD','C');

execute dbms_mview.refresh('"REPTUSER"."VTCMCUST"','F'); ==> With ownername

execute dbms_mview.refresh('"CORP"."NM_SV_RANGE"','F'); ==> FAST refresh


